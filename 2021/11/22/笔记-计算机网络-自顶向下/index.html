<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="写在开头之前现在是2021&#x2F;12&#x2F;29，下月9号考计网，自我感觉良好，昨天把官网所有习题全做了，没遇到很大困难。写这么一小段是提醒以后看我这篇博客复习计网的朋友，《计算机网络：自顶向下》这本书官网自带很好的实验与各章节习题，无论是深入学习网络原理还是考前刷题巩固基础都是极好的，这本书是真的很良心，可是老师授课时却全然没有提及过官网配套学习资源的事情。。。 这些东西错过真的血亏啊！！！贴一个官网在这">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记-计算机网络-自顶向下">
<meta property="og:url" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/index.html">
<meta property="og:site_name" content="FEZ的博客">
<meta property="og:description" content="写在开头之前现在是2021&#x2F;12&#x2F;29，下月9号考计网，自我感觉良好，昨天把官网所有习题全做了，没遇到很大困难。写这么一小段是提醒以后看我这篇博客复习计网的朋友，《计算机网络：自顶向下》这本书官网自带很好的实验与各章节习题，无论是深入学习网络原理还是考前刷题巩固基础都是极好的，这本书是真的很良心，可是老师授课时却全然没有提及过官网配套学习资源的事情。。。 这些东西错过真的血亏啊！！！贴一个官网在这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt1.0.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.0.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.1sender.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.1reciver.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.2.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0sender.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0act1.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0act2.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/GBN.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/GBNreciver.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SR.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SRdilemma.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPformat.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPhandshake.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPclose.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPslowstart.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPcongestioncontrol.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPfair.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/forward_table.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/RouterArchitectureOutview.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SwitchingFabrics.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/IPformat.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DHCP.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/NAT.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/IPv6format.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/tunneling.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/Oscillation.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA1.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA2.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA3.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/networkPhysical.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/CSMA.png">
<meta property="og:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/CSMA_CD.png">
<meta property="article:published_time" content="2021-11-22T06:03:21.000Z">
<meta property="article:modified_time" content="2021-12-29T10:52:50.009Z">
<meta property="article:author" content="FEZ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt1.0.png">


<link rel="canonical" href="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>笔记-计算机网络-自顶向下 | FEZ的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7035c3f4ba1040e0d1972d11a3943ebb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">FEZ的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4%E4%B9%8B%E5%89%8D"><span class="nav-number">1.</span> <span class="nav-text">写在开头之前</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="nav-number">2.</span> <span class="nav-text">第一章</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="nav-number">3.</span> <span class="nav-text">第二章</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="nav-number">4.</span> <span class="nav-text">第三章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.</span> <span class="nav-text">构建可靠数据传输协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GBN"><span class="nav-number">4.2.</span> <span class="nav-text">GBN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0"><span class="nav-number">4.3.</span> <span class="nav-text">选择重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">4.4.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">4.4.1.</span> <span class="nav-text">TCP连接管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">4.4.2.</span> <span class="nav-text">TCP拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E4%B8%80%E4%B8%AATCP%E5%8F%91%E9%80%81%E6%96%B9%E5%8F%91%E9%80%81%E6%B5%81%E9%87%8F%E7%9A%84%E9%80%9F%E7%8E%87"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">1）如何限制一个TCP发送方发送流量的速率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%A6%82%E4%BD%95%E6%84%9F%E7%9F%A5%E6%8B%A5%E5%A1%9E"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">2）如何感知拥塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E4%BD%95%E7%A7%8D%E7%AE%97%E6%B3%95%E6%9D%A5%E6%94%B9%E5%8F%98%E5%8F%91%E9%80%81%E9%80%9F%E7%8E%87"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">3）何种算法来改变发送速率</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%85%A2%E5%90%AF%E5%8A%A8slow-start"><span class="nav-number">4.4.2.3.1.</span> <span class="nav-text">1.慢启动slow start</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">4.4.2.3.2.</span> <span class="nav-text">2.拥塞避免</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="nav-number">4.4.2.3.3.</span> <span class="nav-text">3.快速恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-number">4.4.3.</span> <span class="nav-text">TCP公平性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="nav-number">5.</span> <span class="nav-text">第四章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text">路由器工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3"><span class="nav-number">5.1.1.</span> <span class="nav-text">输入端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2"><span class="nav-number">5.1.2.</span> <span class="nav-text">交换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">经内存交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E6%80%BB%E7%BA%BF%E4%BA%A4%E6%8D%A2"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">经总线交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%8D%A2"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">经互联网络交换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3"><span class="nav-number">5.1.3.</span> <span class="nav-text">输出端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E9%98%9F"><span class="nav-number">5.1.4.</span> <span class="nav-text">排队</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%8E%92%E9%98%9F"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">输入排队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%8E%92%E9%98%9F"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">输出排队</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPv4"><span class="nav-number">5.2.</span> <span class="nav-text">IPv4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80%EF%BC%9A%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.2.1.</span> <span class="nav-text">获取主机地址：动态主机配置协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-Network-Address-Translation-NAT"><span class="nav-number">5.2.2.</span> <span class="nav-text">网络地址转换 Network Address Translation, NAT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPv6"><span class="nav-number">5.3.</span> <span class="nav-text">IPv6</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="nav-number">6.</span> <span class="nav-text">第五章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%AE%97%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">链路状态算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">距离向量算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%9AOSPF"><span class="nav-number">6.3.</span> <span class="nav-text">因特网自治系统内部的路由选择：OSPF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ISP%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%9ABGP"><span class="nav-number">6.4.</span> <span class="nav-text">ISP之间的路由选择：BGP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="nav-number">7.</span> <span class="nav-text">第六章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E9%93%BE%E8%B7%AF%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.</span> <span class="nav-text">多路访问链路和协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.1.</span> <span class="nav-text">信道划分协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%8E%A5%E5%85%A5%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.2.</span> <span class="nav-text">随机接入协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AECSMA"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">载波侦听多路访问CSMA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AE%E6%B5%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.3.</span> <span class="nav-text">轮流协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E5%AF%BB%E5%9D%80%E5%92%8CARP"><span class="nav-number">7.2.</span> <span class="nav-text">链路层寻址和ARP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">8.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%B4%E8%B0%A2"><span class="nav-number">9.</span> <span class="nav-text">致谢</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FEZ"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">FEZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          笔记-计算机网络-自顶向下
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-22 14:03:21" itemprop="dateCreated datePublished" datetime="2021-11-22T14:03:21+08:00">2021-11-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-29 18:52:50" itemprop="dateModified" datetime="2021-12-29T18:52:50+08:00">2021-12-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="写在开头之前"><a href="#写在开头之前" class="headerlink" title="写在开头之前"></a>写在开头之前</h1><p>现在是2021/12/29，下月9号考计网，自我感觉良好，昨天把官网所有习题全做了，没遇到很大困难。写这么一小段是提醒以后看我这篇博客复习计网的朋友，《计算机网络：自顶向下》这本书官网自带很好的实验与各章节习题，无论是深入学习网络原理还是考前刷题巩固基础都是极好的，这本书是真的很良心，可是老师授课时却全然没有提及过官网配套学习资源的事情。。。</p>
<p>这些东西错过真的血亏啊！！！贴一个<a target="_blank" rel="noopener" href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/">官网</a>在这里，打算复习知识点、巩固基础的朋友千万别错过这么好的资源，官网的题是必做的。毕竟书都是人家写的，无条件相信就好。</p>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>主机<code>host</code>就是端系统<code>end system</code></p>
<p>端系统通过通信链路<code>communication link</code>和分组交换机<code>packet switch</code>连接到一起</p>
<p>分组交换机包括：路由器<code>router</code>和链路层交换机<code>link-layer switch</code></p>
<p>端系统通过因特网服务提供商<code>Internet Service Provider, ISP</code>接入因特网</p>
<p>多数分组交换机在链路的输入端使用存储转法传输<code>store-and-forward transmission</code>机制。存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到完整的分组</p>
<p>通过网络链路和交换机移动数据有两种基本方法：电路交换<code>circuit switching</code>和分组交换<code>packet switching</code>，在电路交换中，<strong>预留</strong>了端系统间沿路径通信所需的资源（缓存，链路传输速率）。传统的电话网络就是电路交换的例子，在电话拨通前，已在电话网上留出资源，保证了能以恒定速率传输数据。而分组交换并不预留资源，因此当其他分组也需要经过该链路传输时，可能发生拥塞，则该分组不得不在传输链路发送测的缓存中等待而产生时延。</p>
<p>链路上的电路是通过<strong>频分复用</strong><code>Frequency-Division Multiplexing, FDM</code>或<strong>时分复用</strong><code>Time-Division Multiplexing, TDM</code>实现的。电路交换的缺点是不能实现资源的高效利用。比如以时分复用为例，假设将一秒分为1帧，而1帧分为5个时隙，则一个时隙为0.2秒。若建立了一个连接需要通过该链路传数据，该连接分得一个时隙，那么即使该链路上此时就这一个连接在传数据，在1秒内它也只能使用分配给它的0.2秒传数据，剩下0.8秒浪费掉了</p>
<p>一个分组从一个节点传播到后继节点，该分组在每个节点经受了几种不同类型的实现，其中最为重要的是<strong>处理时延</strong><code>processing delay</code>，<strong>排队时延</strong><code>queuing delay</code>，<strong>传输时延</strong><code>transmission delay</code>和<strong>传播时延</strong><code>propagation delay</code>，这几个时延加起来就是<strong>节点的总时延</strong><code>nodal processing delay</code></p>
<p>5层因特网协议（自顶向下）：应用层，运输层，网络层，链路层，物理层</p>
<p>7层ISO OSI参考模型（自顶向下）：应用层，表示层，会话层，运输层，网络层，链路层，物理层</p>
<p>两个协议模型相比较，OSI模型多了两层：表示层（使得通信的应用程序能够解释交换数据的含义）和会话层（提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法）。因特网缺少了OSI参考模型中的两个层次，我们问：这些层次提供的服务不重要吗？如果一个应用程序需要这些服务之一将会怎样呢？因特网对这两个问题的回答相同：这留给应用程序开发者处理。如果一个服务重要，应用程序开发者就应该在应用程序中构建该功能</p>
<p>典型应用层协议如：HTTP（提供Web文档的请求和传送）、SMTP（提供了电子邮件报文的传输）和FTP（提供两个端系统之间的文件传送）；典型的运算层协议如TCP和UDP；典型的网络层协议如IP；链路层的例子如以太网，WiFi和电缆接入网的DOCSIS协议</p>
<p>位于应用层的信息分组称为<strong>报文</strong><code>message</code>，运输层的分组称为<strong>报文段</strong><code>segment</code>，网络层负责将<strong>数据报</strong><code>datagram</code>从一台主机传到另一台主机，我们称链路层分组为<strong>帧</strong><code>frame</code>。对于运输层报文段、网络层数据报和链路层帧而言，一个分组具有两种类型的字段：首部字段和<strong>有效载荷字段</strong><code>payload field</code></p>
<p>链路层交换机实现了物理层和链路层，路由器实现了物理层、链路层和网络层，这意味着路由器能实现IP协议，而链路层交换机不能</p>
<p>拒绝服务攻击<code>Denial-of-Service (DoS) attack</code>短时间内猛烈地向目标发送流量，拥塞网络，使服务陷入瘫痪；分布式DoS<code>Distributed Dos, DDoS</code>从多个源点向目标发送流量</p>
<p>记录每个流经的分组的副本的被动接收机被称为<strong>分组嗅探器</strong><code>packet sniffer</code>；将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗</strong><code>IP spoofing</code></p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>由于套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序与网络之间的<strong>应用程序编程接口</strong><code>Application Programming Interface, API</code></p>
<p>Web的应用层协议是<strong>超文本传输协议</strong><code>HyperText Transfer Protocol, HTTP</code></p>
<p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短几秒内两次请求同一对象，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个<strong>无状态协议</strong><code>stateless protocol</code></p>
<p><strong>往返时间</strong><code>Round-Trip Time, RTT</code>：是指一个短分组从客户到服务器然后再返回客户所花费的时间</p>
<p>典型的HTTP请求报文</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="regexp">/somedir/</span>page.html HTTP<span class="regexp">/1.1		/</span>/请求行 request line</span><br><span class="line"><span class="attr">Host:</span> www.someschool.edu			<span class="comment">//首部行 header line</span></span><br><span class="line"><span class="attr">Connection:</span> close					<span class="comment">//首部行</span></span><br><span class="line">User-<span class="attr">agent:</span> Mozilla<span class="regexp">/5.0				/</span>/首部行</span><br><span class="line">Accept-<span class="attr">language:</span> fr					<span class="comment">//首部行</span></span><br></pre></td></tr></table></figure>

<p>请求行有三个字段：方法字段、URL字段和HTTP版本字段；首部行<code>Host: www.someschool.edu</code>指明了对象所在的主机；<code>Connection: close</code>指明不使用持续连接，让服务器发送完请求的对象后就关闭这条连接；<code>User agent</code>用来指明用户代理，即向服务器发送请求的浏览器类型；最后，<code>Accept-language</code>表示用户希望得到该对象的法语版本</p>
<p>Web缓存器<code>Web cache</code>也叫代理服务器<code>proxy server</code>，是能够代表初始Web服务器来满足自己的磁盘存储的网络实体。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦服务器被配置，每个对某个对象的服务器请求首先被定向到该Web缓存器。举例而言，假设浏览器正在请求对象<code>http://www.someschool.edu/campus.gif</code>，将会发生如下情况：</p>
<p>1）浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求</p>
<p>2）Web缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web缓存器向客户浏览器用HTTP响应报文返回该对象</p>
<p>3）如果没有，它就打开一个与该对象的初始服务器（即<code>www.someschool.com</code>）的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应</p>
<p>4）当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本（通过现有的客户浏览器和Web缓存器之间的TCP连接）</p>
<p>因特网电子邮件系统的三个主要组成部分：<strong>用户代理</strong><code>user agent</code>、<strong>邮件服务器</strong><code>mail server</code>和<strong>简单邮件传输协议</strong><code>Simple Mail Transfer Protocol, SMTP</code>；一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中</p>
<p>SMTP是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。每台邮件服务器上既运行SMTP客户端又运行SMTP服务器端</p>
<p>为描述SMTP的基本操作，我们观察一种常见的情景。假设Alice想给Bob发送一封简单的ASCII报文。</p>
<p>1）Alice调用她的邮件代理程序并提供Bob的邮件地址，撰写报文，然后指示用户代理发送该报文</p>
<p>2）Alice的用户代理把报文发送给她的邮件服务器，在那里该报文被放在报文队列中</p>
<p>3）运行在Alice的邮件服务器上的SMTP客户端发现了报文队列中的这个报文，它就创建一个到运行Bob的邮件服务器上的SMTP服务器的TCP连接</p>
<p>4）在经过一些初始SMTP握手后，SMTP客户通过该TCP连接发送Alice的报文</p>
<p>5）在Bob的邮箱服务器上，SMTP的服务器端接收该报文。Bob的邮件服务器然后将该报文放入Bob的邮箱中</p>
<p>6）在Bob方便的时候，他调用用户代理阅读该报文</p>
<p>思考：Alice想要向Bob发送电子邮件，她首先将邮件推送到自己的邮件服务器，再由邮件服务器将邮件发给Bob的邮件服务器。为什么该过程要分成两步呢？主要是因为如果不通过Alice的邮件服务器进行中继，Alice的用户代理将没有任何办法到达一个不可达的目的地接收服务器。通过首先将邮件存放在自己的邮件服务器中，Alice的邮件服务器可以重复地尝试向Bob的邮件服务器发送该报文。</p>
<p>还有一个值得思考的点：像Bob这样的接收方，是如何通过运行其本地PC上的用户代理获得位于他的某ISP的邮件服务器上的邮件呢？要知道，用户代理不能使用SMTP得到报文，因为取报文是一个拉操作，而SMTP是一个推协议。通过引入一个特殊的邮件访问协议来解决这个难题，该协议将Bob邮件服务器上的报文传送给他的本地PC。目前流行的一些邮件访问协议：<strong>第三版的邮局协议</strong><code>Post Office Protocol Version 3, POP3</code>、<strong>因特网邮件访问协议</strong><code>Internet Mail Access Protocol, IMAP</code>以及HTTP</p>
<p>主机能有许多不同的名字。人类喜欢便于记忆的主机名标识方式，而路由器喜欢定长的、有层次结构的IP地址。为了折中这种偏好，需要一种能进行主机名到IP地址转换的目录服务。这就是<strong>域名系统</strong><code>Domain Name System, DNS</code>的主要任务。DNS是一个由分层的DNS服务器<code>DNS server</code>实现的分布式数据库，也是一个使得主机能够查询分布式数据库的<strong>应用层协议</strong>。DNS协议运行在UDP之上，使用53号端口。</p>
<p>考虑运行在某用户主机上的浏览器请求URL<code>www.someschool.com/index.html</code>页面时会发生什么现象。为了使用户的主机能够将一个HTTP请求报文发送到Web服务器<code>www.someschool.com</code>，该用户主机必须获得<code>www.someschool.com</code>的IP地址。其做法如下。</p>
<p>1）同一台用户主机上运行着DNS应用的客户端</p>
<p>2）浏览器从上述URL中抽出主机名<code>www.someschool.com</code>，并将这台主机名传给DNS应用的客户端</p>
<p>3）DNS客户向DNS服务器发送一个包含主机名的请求</p>
<p>4）DNS客户最终会收到一份回答报文，其中含有对应该主机的IP地址</p>
<p>5）一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器发起一个TCP连接</p>
<p>除了进行主机名到IP地址的转换外，DNS还提供一些重要的服务：<strong>主机别名</strong><code>host aliasing</code>，有复杂主机名的主机能拥有一个或多个（也许）更容易记忆的别名，但只有一个<strong>规范主机名</strong><code>canonical hostname</code>；<strong>邮件服务器别名</strong><code>mail server aliasing</code>，各项功能基本同主机别名；<strong>负载分配</strong><code>load distribution</code></p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong><code>logic communication</code>功能。从应用程序角度看，通过逻辑通信，运行不同进程的主机好想直接相连一样</p>
<p>网络层提供了<em>主机</em>之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信</p>
<p>IP是<strong>不可靠服务</strong><code>unreliable service</code></p>
<p>将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用</strong><code>transport-layer multiplexing</code>与<strong>多路分解</strong><code>demultiplexing</code></p>
<h2 id="构建可靠数据传输协议"><a href="#构建可靠数据传输协议" class="headerlink" title="构建可靠数据传输协议"></a>构建可靠数据传输协议</h2><p><strong>1.经完全可靠信道的可靠数据传输：rdt1.0</strong></p>
<p>假定分组按发送次序进行交付</p>
<p>没有差错！没有丢包！</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt1.0.png" class>

<p><strong>2.经具有比特差错信道的可靠数据传输：rdt2.0</strong></p>
<p>仍然假设按序交付</p>
<p>没有丢包！可能出错</p>
<p>每发送一个分组，发送方等待接收方反馈，若收到NAK，重传分组</p>
<p>每接收一个分组，接收方发送反馈（ACK，NAK）</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.0.png" class>

<p>注意到：当发送方处于等待ACK或NAK状态时，它不能从上层获得更多数据；这就是说，<code>rdt_send()</code>事件不可能出现；仅当接收到ACK并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，<code>rdt2.0</code>这样的协议被称为<strong>停等</strong><code>stop-and-wait</code>协议</p>
<p><strong>3.进一步考虑比特差错的可靠数据传输：rdt2.1</strong></p>
<p><code>rdt2.0</code>只考虑到了对发送方发往接收方的数据进行差错检测，但却忽略了接收方的反馈出错这种情况。假设发送方向接收方发送了一个分组，无论出错与否，接收方都向其发送反馈分组，不幸的是该反馈分组在传输过程中产生比特差错，当发送方接收到该信号后发现该分组是错误的，这时它该怎么办呢？<code>rdt2.0</code>协议无法解决这个问题，于是我们对其稍作改良：当发送方发现反馈分组是错误的时，它不知晓接收方到底有没有正确接收分组，为保险起见，发送方重发刚才的分组。但这里又有个问题：接收方如何区分其接收到的分组是一个新的分组还是重传分组呢？为实现能够对分组进行区分，在数据分组中添加一个新字段，将发送方分组的<strong>序号</strong><code>sequence number</code>放在该字段，于是接收方只需要检查序号即可确定收到的分组是否是一次重传</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.1sender.png" class>

<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.1reciver.png" class>

<p><strong>4.rdt2.1的变种：rdt2.2</strong></p>
<p><code>rdt2.2</code>实现的功能和<code>rdt2.1</code>完全相同，只是实现的方法不同。<code>rdt2.2</code>取消了NAK信号，无论接收方接收到的是预期想要的分组还是一个出错的分组都使用ACK信号进行反馈。如果接收方在期待一个序号值为0的分组，而接收到的分组序号值为1，接收方知道这是一个重传分组，于是向发送方发送一个<code>ACK 1</code>信号，代表接收方已接收到该序列号为1的重传分组。当发送方接收到此<code>ACK 1</code>信号时，自然知道该发送新的、序列值为0的分组</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.2.png" class>

<p><strong>5.经具有比特差错的丢包信道的可靠数据传输：rdt3.0</strong></p>
<p>现假定除比特受损外，底层信道还会丢包。协议必须处理两个问题：怎样检查丢包以及发生丢包后该做些什么。发送方发送分组后，等待一段时间，若没能得到应答（可能发送分组丢失，或是反馈分组丢失，亦或是网络拥塞，分组堵在路上了），为保险起见，发送方重传分组，再等待一段时间，如此往复直至收到接收方应答反馈</p>
<p>为实现基于时间的重传机制，需要一个<strong>倒计时计数器</strong><code>countdown timer</code>，在一个给定的时间量过期后，可中断发送方。因此，发送方需要能够做到：1.每次发送一个分组（包括第一次分组和重传分组）时，启动一个定时器；2.响应定时器中断（采取适当的动作）；3.终断定时器。于是便得到<code>rdt3.0</code>协议</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0sender.png" class>

<p><code>rdt3.0</code>的接收方相较于<code>rdt2.2</code>的接收方FSM并没有变化</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0act1.png" class>

<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0act2.png" class>

<p><code>rdt3.0</code>给人感觉不错，已经是一个考虑比较周全的协议，但其实质仍是一个停等协议，效率太低，故考虑<strong>流水线</strong><code>pipelining</code>技术，一次性传多个分组，带来的影响有：1）必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中的未确认报文；2）协议发送方和接收方不得不缓存多个分组；3）如何处理丢失、损坏及延时过大的分组</p>
<p>解决流水线差错恢复两种基本方法是：<strong>回退N步</strong><code>Go-Back-N, GBN</code>和<strong>选择重传</strong><code>Selective Repeat, SR</code></p>
<h2 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h2><img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/GBN.png" class>

<p>图中显示了发送方看到的GBN协议的序号范围，如果我们将<strong>基序号</strong><code>base</code>定义为最早未确认分组的序号，将<strong>下一个序号</strong><code>nextseqnum</code>定义为最小的未使用序号（即下一个待发分组的序号），则可将序号范围分割为4段。在<code>[0, base - 1]</code>段内的序号对应于已经发送并被确认的分组，<code>[base, nextseqnum - 1]</code>段内的序号对应于已经发送并被确认的分组。<code>[nextseqnum, base + N - 1]</code>段内的序号能用于那些要被立即发送的分组（如果有数据来自上层的话），最后，大于或等于<code>base + N</code>的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为<code>base</code>的分组）已得到确认为止</p>
<p>已被发送但还未确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N常被称为<strong>窗口长度</strong><code>window size</code>，GBN协议也常被称为<strong>窗口滑动协议</strong><code>sliding-window protocol</code></p>


<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/GBNreciver.png" class>

<p>注意，在GBN协议中，接收端窗口大小始终为1，当其接收到正确但失序的分组只是将其简单的丢弃</p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SR.png" class>

<p>我个人更喜欢选择重传</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SRdilemma.png" class>

<p>不过需注意，接收端窗口大小需小于等于发送端窗口大小的一半（向下取整），否则会出问题。试想，如果发送端窗口大小为2X，接收端窗口大小为X。发送端先发送序号<code>1 ~ X</code>共X个分组，接收端全接收到，刚好把接收端窗口填满，接收端向后移动X个单位，假设接收端的所有ACK信号全部丢失，待超时时，发送端重发<code>1 ~ X</code>分组，接收端窗口此时期待的序号范围为<code>X + 1 ~ 2X</code>，保证发送端重发的分组的序号不会和接收端窗口期代的新的序号有重叠，避免了上图里情况的发生</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP被称为是<strong>面向连接的</strong><code>connection-oriented</code>，这是因为在一个应用程序可以开始向另一个应用程序发送数据之前，这两个进程必须先“握手”。这种TCP“连接”不是一条像在电路交换网络中的端到端TDM或FDM电路。相反，该“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接</p>
<p>一旦建立起一条TCP连接，两个应用进程之间就可以互相发送数据了。客户进程通过套接字传递数据流，TCP将这些数据引导到该连接的<strong>发送缓存</strong><code>send buffer</code>。TCP可从缓存中取出并放入报文段中的数据数量受限于<strong>最大报文段长度</strong><code>Maximum Segment Size, MSS</code>。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的<strong>最大传输单元</strong><code>Maximum Transmission Unit, MTU</code>）来设置。注意到MSS是指报文段里应用层数据的最大长度，而不是指包含首部的TCP报文段的最大长度</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPformat.png" class>

<p>TCP把数据看成一个无结构的、有序的字节流。<strong>一个报文段的序号</strong><code>sequence number for a segment</code>因此是该报文段首字节的字节流编号。主机A填充进报文段的确认号是主机A希望从主机B收到的下一字节的序号。例如，假设主机A已收到来自主机B的编号为0~535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536</p>
<p>TCP采用<strong>累计确认</strong><code>cumulative acknowledgment</code></p>
<p>TCP为它的应用程序提供了<strong>流量控制服务</strong><code>flow-control service</code>以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。TCP发送方也可能因为IP网络的拥塞而被遏制；这种形式的发送方控制被称为<strong>拥塞控制</strong><code>congestion control</code>。流量控制和拥塞控制采取的动作非常相似，但它们是针对完全不同的原因而采取的措施。流量控制是为了更好的服务两个端系统上的应用程序，而拥塞控制则是着眼整个网络</p>
<p>TCP通过让<em>发送方</em>维护一个称为<strong>接收窗口</strong><code>receive window</code>的变量来提供流量控制。该窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。假设主机A通过一条TCP连接向主机B发送要给大文件，主机B为该连接分配了一个接收缓存，并用<code>RevBuffer</code>表示其大小。我们定义以下变量：</p>
<p><code>LastByteRead</code>：主机B上的应用程序从缓存读出的数据流的最后一个字节的编号</p>
<p><code>LastByteRcvd</code>：从网络中到达的并且已经放入主机B接收缓存中的数据流的最后一个字节的编号</p>
<p>由于TCP不允许已分配的缓存溢出，因此<code>LastByteRcvd - LastByteRead &lt;= RevBuffer</code>成立</p>
<p>接收窗口用<code>rwnd</code>表示，根据缓存可用空间的数量来设置。<code>rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</code>，由于该空间是随着时间变化的，所以<code>rwnd</code>是动态变化的</p>
<p>开始时，主机A设定<code>rwnd = RcvBuffer</code>，主机A轮流跟着两个变量，<code>LastByteSent</code>和<code>LastByteAcked</code>，注意到这两个变量之差就是主机A发送到连接但未被确认的数据量。通过将未确认的数据量控制在值<code>rwnd</code>以内，就可以保证主机A不会使主机B的接收缓存溢出。因此有<code>LastByteSent - LastByteAcked &lt;= rwnd</code></p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP连接建立：<strong>三次握手</strong><code>three-way handshake</code></p>
<p>1）客户端的TCP首先向服务器端的TCP发送一个特殊TCP报文段。该报文段不包含应用层数据，但报文段首部的一个标志位SYN被置1，并且客户会随机选择一个初始化序号<code>client_isn</code></p>
<p>2）一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器从数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户发送允许连接的报文段。该报文段同样不含应用层数据，SYN位置一，确认号字段被置为<code>client_isn + 1</code>，同时将服务器的初始序号<code>server_isn</code>放置到报文段的序号字段中。该允许连接报文段被称为<strong>SYNACK报文段</strong><code>SYNACK segment</code></p>
<p>3）客户端收到SYNACK报文段后，也要为该TCP连接分配缓存和变量，并再向服务器端发送报文来对服务器的允许连接的报文段进行确认（通过将<code>server_isn + 1</code>放置到TCP报文段首部的确认字段来完成此项工作）。因为连接已建立，所以该报文SYN位置零，并且可以在此报文段携带客户到服务器的数据</p>
<p>一旦完成以上三个步骤，客户和服务器主机就可以互相发送包括数据的报文段了。在以后的每一个报文段中，SYN位都置零</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPhandshake.png" class>

<p>第一次握手<code>SYN = 1</code>,客户初始序号，没有数据但消耗一个序号；第二次握手<code>SYN = 1</code>，服务器初始化序号，没有数据，也消耗一个序号；第三次握手<code>SYN = 0</code>，SYN置零，可以包含数据</p>
<p>TCP连接关闭：四次挥手</p>
<p>参与一条TCP连接的<strong>两个进程中的任意一个</strong>都能终止该连接。当连接结束后，主机中的资源（即缓存和变量及端口）都将被释放</p>
<p>1）打算关闭连接的一方A向另一方B发送一个特殊的TCP报文段。该报文段首部的一个标志位FIN被置一</p>
<p>2）当B接收到该FIN报文段后，就向发送方A回送一个ACK确认报文段</p>
<p>3）B也向A发送一个FIN置一的TCP报文段</p>
<p>4）当A收到该报文段后，A同理回送一个ACK确认报文段</p>
<p>至此，双方互相确认完毕断开连接，回收资源</p>
<p>实际中，当第四步A回送确认报文段后并不离开回收资源，而会等一会（可能三十秒或一分钟？具体时间与具体实现相关）,A处于<code>TIME_WAIT</code>状态。假定ACK丢失，<code>TIME_WAIT</code>状态使A重传最后的确认报文。经等待后，连接就正式关闭，释放资源</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPclose.png" class>

<p><strong>SYN洪泛攻击</strong><code>SYN flood attack</code></p>
<p>我们在三次握手中已看到，服务器为了响应一个收到的SYN，分配初始化连接变量和缓存，然后服务器发送一个SYNACK进行响应，并等待来自客户的ACK报文段。如果某客户不发送ACK来完成三次握手的第三步，最终（可能半分钟后）服务器终止并断开该半开连接并回收资源，这为DoS攻击即SYN洪泛攻击提供了环境。随着这种SYN报文纷沓而来，服务器不断为这些半开连接分配资源，导致最终资源消耗殆尽。一种称为<strong>SYN cookie</strong>的技术能有效防御该种攻击</p>
<p>SYN cookie工作原理：当服务器收到一个SYN报文段时并不分配资源。服务器生成一个初始TCP序列号，该序列号是SYN报文段的源和目的IP地址与端口以及仅有该服务器知道的秘密数的一个复杂函数（散列函数）。这种精心制作的初始序列号被称为<code>cookie</code>。服务器则发送具有这种特殊初始序列号的SYNACK分组。<strong>重要的是，服务器并不记忆该<code>cookie</code>或任何对应于SYN的其他状态信息</strong></p>
<p>如果客户是合法的，它将返回一个ACK报文，该报文的确认字段中的数值应该等于用该报文的源和目的IP地址与端口算出来的<code>cookie</code>值再加一。服务器为满足该条件的客户分配资源，建立连接。如此这般，无论客户不返回ACK报文或是返回一个伪造的报文，都不会消耗服务器资源</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>TCP采用端到端拥塞控制而不是网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。如果一个TCP发送方感知沿该路径有拥塞，则发送方会降低其连接发送流量的速率。但这种方法提出了三个问题：1）一个TCP发送方如何限制它向其他连接发送流量的数据呢？2）一个TCP发送方如何感知从它到目的地之间的路径存在拥塞呢？3）采用何种算法来改变其发送速率呢？</p>
<h4 id="1）如何限制一个TCP发送方发送流量的速率"><a href="#1）如何限制一个TCP发送方发送流量的速率" class="headerlink" title="1）如何限制一个TCP发送方发送流量的速率"></a>1）如何限制一个TCP发送方发送流量的速率</h4><p>运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即<strong>拥塞窗口</strong><code>congestion window</code>。拥塞窗口表示为<code>cwnd</code>，它对一个TCP发送方能向网络中发送流量的速率进行了限制。已发送但没被确认的数据量满足以下限制：</p>
<p><code>LastByteSent - LastByteAcked &lt;= min&#123; cwnd, rwnd &#125;</code></p>
<p>为关注拥塞控制（与流量控制形成对比），假设<code>rwnd</code>足够大，以至于可以忽略接收窗口的限制；因此在发送方中未被确认的数据量受限于<code>cwnd</code>。通过调整<code>cwnd</code>大小即可动态控制发送速率</p>
<h4 id="2）如何感知拥塞"><a href="#2）如何感知拥塞" class="headerlink" title="2）如何感知拥塞"></a>2）如何感知拥塞</h4><p>简单！丢包事件发生（超时或3次冗余ACK）即意味着网络拥塞，发送方应减小拥塞窗口大小，降低传输速率；另一方面，若发送方收到对于以前未确认的报文段的确认，则将其理解为一切正常的指示，增大拥塞窗口大小，增加发送速率。而且，如果确认以低速率到达，则拥塞窗口应以低速率增大；确认以高速率达到则拥塞窗口以高速率增大</p>
<h4 id="3）何种算法来改变发送速率"><a href="#3）何种算法来改变发送速率" class="headerlink" title="3）何种算法来改变发送速率"></a>3）何种算法来改变发送速率</h4><p>通过广受赞誉的<strong>TCP拥塞控制算法</strong><code>TCP congestion control algorithm</code>实现。该算法包括三个主要部分：慢启动、拥塞避免和快速恢复（快速恢复是推荐部分，而不是必需的）</p>
<h5 id="1-慢启动slow-start"><a href="#1-慢启动slow-start" class="headerlink" title="1.慢启动slow start"></a>1.慢启动<code>slow start</code></h5><p>当一条TCP连接开始时，<code>cwnd</code>的值通常初始置为一个MSS的较小值，每当传输报文段首次被确认就就增加一个MSS。这样，1至2，2至4，4至8…每过一个RTT，发送速率就翻番，直至丢包事件发生（超时或三次冗余ACK）</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPslowstart.png" class>

<p>若超时，将状态变量<code>ssthresh</code>（”慢启动阈值“的速记）的值设为此时<code>cwnd</code>大小的一半，重设<code>cwnd</code>值为1并重新进行慢启动。当<code>cwnd</code>窗口大小又逐渐增大至<code>ssthresh</code>，继续使<code>cwnd</code>翻番可能有些鲁莽，于是进入拥塞避免阶段</p>
<h5 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2.拥塞避免"></a>2.拥塞避免</h5><p>在拥塞避免阶段，TCP无法每个RTT再将<code>cwnd</code>值翻番，而是采取保守方法，每次RTT只将其增大一个MSS大小</p>
<h5 id="3-快速恢复"><a href="#3-快速恢复" class="headerlink" title="3.快速恢复"></a>3.快速恢复</h5><p>懒得打字了</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPcongestioncontrol.png" class>

<h3 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h3><p>考虑K条TCP链接，每条都有不同的端到端路径，但都经过一段传输速率为R bps的瓶颈链路。假设每条连接都在传输一个大文件，而且无UDP流量通过该段瓶颈链路。如果每条连接的平均传输速率接近<code>R/K</code>，即每条连接都得到相同份额的链路带宽，则认为该拥塞控制机制是公平的。而TCP的AIMD拥塞控制算法是<strong>公平的</strong></p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPfair.png" class>

<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p><strong>转发</strong><code>forwarding</code>是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。转发发生的时间尺度很短（通常为几纳秒），因此通常用硬件来实现</p>
<p><strong>路由选择</strong><code>routing</code>是指确定分组从源到目的地所采用的端到端路径的网络范围处理过程。时间尺度长的多（通常几秒），因此通常软件实现</p>
<p>考虑一个驾驶员从宾夕法尼亚州到佛罗里达州的行程。在行程中该驾驶员经过了许多立交桥。我们能够认为<strong>转发</strong>就像通过<strong>单个立交桥</strong>的过程：一辆汽车从其道路上进入立交桥的一个入口，并且决定应当走哪条路来离开该立交桥。我们可以把<strong>路由选择</strong>看作是<strong>规划从宾夕法尼亚州到佛罗里达州行程</strong>的过程：在着手行程前，驾驶员已经查阅了地图并在许多可能的路径中选择一条，其中每条路径都由一系列经立交桥连接的路段组成</p>
<p>网络层的数据平面执行主要功能就是转发，而网络层的控制平面执行的主要功能是路由选择</p>
<p>每台网络路由器中有一个关键元素是它的转发表<code>forwarding table</code>。路由器检查到达分组首部的一个或多个字段，进而使用这些首部值在其转发表中索引来转发分组</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/forward_table.png" class>

<p>于是我们不禁思考：路由器中的转发表一开始是如何配置的呢？</p>
<p>传统的方法是，在每条路由器中运行路由选择算法，由路由选择算法决定插入该路由器转发表中的内容，故每台路由器都包含转发和路由选择两种功能。一台路由器中的路由选择算法与在其他路由器中的路由选择算法通信，以计算出它的转发表值。这种通信又是如何执行呢？通过根据路由选择协议交换包含路由选择信息的路由选择报文！</p>
<p>而另一种方法，<strong>软件定义网络</strong><code>Software-Defined Networking, SDN</code>，将路由选择从路由器中分离：远程控制器计算和分发转发表以供每台路由器使用，而<strong>路由设备仅执行转发</strong>。远程控制器可能实现在具有高可靠性和冗余的远程数据中心中，并可能由ISP或某些第三方管理。路由器和远程控制器是如何通信呢？通过交换包含转发表和其他路由选择信息的报文</p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p>下图显示了一个通用路由器体系结构的总体视图</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/RouterArchitectureOutview.png" class>

<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p>图左边的<strong>输入端口</strong><code>input port</code>表现为一个大的矩形，每个端口矩形内部还有三个方框，其中左起第一个绿色方框负责执行终结入物理链路的物理层功能（线路端接），中间棕色方块代表端口负责与位于入链路远端的数据链路层交互来执行数据链路层功能（数据链路处理（协议，拆封）），右边的红色方块代表端口要执行的查找功能（查找，转发，排队）</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>存在三种交换结构用于总体视图中交换结构的实现：经内存交换，经总线交换和经互联网交换</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SwitchingFabrics.png" class>

<h4 id="经内存交换"><a href="#经内存交换" class="headerlink" title="经内存交换"></a>经内存交换</h4><p>通过将输入端口传入的分组数据复制于内存，由路由选择处理器于其首部提取目的地址，在转发表中找出适当的输出端口，并将该分组复制到输出端口的缓存中。假设内存带宽为每秒可读写进内存或从内存读出最多B个分组，则总转发吞吐量必然小于B/2。也要注意到不能同时转发两个分组，即使它们有不同的目的端口，因为经过共享系统总线一次仅能执行一个内存读写</p>
<h4 id="经总线交换"><a href="#经总线交换" class="headerlink" title="经总线交换"></a>经总线交换</h4><p>输入端口经一根共享总线将分组直接传输到输出端口，不需要路由选择处理器的干预。通过让输入端口为分组预先计划一个交换机内部标签（首部），指示本地输出端口，使分组在总线上传送和传输到输出端口。该分组能由所有输出端口收到，但只有与该标签匹配的端口才能保存该分组，然后标签在输出端口被去除。采用该方法，除了一个分组外所有其他分组必须等待，因为一次只有一个分组能够跨越总线</p>
<h4 id="经互联网络交换"><a href="#经互联网络交换" class="headerlink" title="经互联网络交换"></a>经互联网络交换</h4><p>如上述PPT中右侧图片所示，纵横式交换机是<strong>非阻塞的</strong><code>non-blocking</code>，即只要没有其他分组当前被转发到该输出端口，转发到输出端口的分组将不好被到达输出端口的分组阻塞。当然，如果两个不同的输入端口同时打算转发至相同输出端口，则其中一个需要等待</p>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p>输出端口做的事情有点像是输入端口的逆过程，从左到右三个子方框分别代表：1）排队（缓存管理），2）数据链路处理（协议，封装），3）线路端接</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><h4 id="输入排队"><a href="#输入排队" class="headerlink" title="输入排队"></a>输入排队</h4><p>何时会出现输入排队呢？试想，一台路由器有N个输入端口，假设每个时间单位内每个输入端口均收到一个分组，若在该时间单位内交换结构不能将N个分组全部转发，那么必然部分输入端口在该时间单位内没能来得及将分组转发，而一个时间单位后又有新的分组到达。如果这种情形一致持续，每个时间单位内都有部分输入端口得不到转发，总体来看，平均每个输入端口的队列将越来越长，直至最终缓存溢出，丢包事件发生</p>
<h4 id="输出排队"><a href="#输出排队" class="headerlink" title="输出排队"></a>输出排队</h4><p>何时会出现输出排队呢？假设交换结构是纵横式的，一个时间单位内N个输入端口均收到分组，且这些分组全都需要转发至同一输出端口，而交换结构工作得够快，能够在一个时间单位内将N个分组全部转发至目标端口。而不幸的是该输出端口没有能力在一个时间单位内将N个分组全部传输，如果在一段时间内持续不断的许多分组转发至同一输出端口，当输出端口没有足够的内存来缓存一个入分组时，就必须做出决定：要么丢弃到达的分组（采用一种称为<strong>弃尾</strong><code>drop-tail</code>的策略），要么删除一个或多个已排队的分组来为新来的分组腾出空间。在某些情况下，在缓存填满之前便丢弃一个分组，以向发送方提供一个拥塞信号是有利的。这种策略统称为<strong>主动队列管理</strong><code>Active Queue Management, AQM</code>，<strong>随机早期检测</strong><code>Random Early Detection, RED</code>算法是得到最广泛研究和实现的AQM算法之一</p>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/IPformat.png" class>

<p> 一个链路层帧能承载的最大数据量叫作被叫作<strong>最大传送单元</strong><code>Maximum Transmission Unit, MTU</code>。如果IP数据报过大，将其分片为多个较小的IP数据报，用单独的链路层帧封装这些较小的IP数据报，然后通过输出链路发送这些帧。每个这些较小的数据报都称为<strong>片</strong><code>fragment</code></p>
<p>分片后，并不是从该路由器发往下一个路由器又重新组装，而是待所有的片到达端系统后再组装</p>
<p>一台主机通常只有一条链路连接到网络，当一台主机中的IP想要发送一个数据报时，它就在该链路上发送。主机和物理链路之间的边界叫作<strong>接口</strong><code>interface</code>。现在考虑一台路由器及其接口。因为路由器的任务是从链路上接收数据报并从某些其他链路转发出去，路由器必须拥有两条或者更多链路与它连接。路由器与它的任意一条链路之间的边界也叫作接口。一台路由器因此有多个接口，每个接口有其链路。因为每台主机与路由器都能发送和接收IP数据报，IP要求每台主机和路由器接口拥有自己的IP地址。<strong>因此，从技术上讲，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联</strong></p>
<p>因特网的地址分配策略被称为<strong>无类别域间路由选择</strong><code>Classless Interdomain Routing, CIDR</code>。形式为<code>a.b.c.d/x</code>的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的<strong>前缀</strong><code>prefix</code>（或网络前缀）。一个地址的剩余<code>32 - x</code>比特可认为是用于区分该组织内部设备的，其中的所有设备具有相同的网络前缀。当该组织内部的路由器转发分组时，才会考虑这些比特。也就是说，当该组织外部的一台路由器转发一个数据报，且该数据报的目的地址位于该组织内部时，仅需要考虑该地址的前x比特。这相当大程度地减少了在这些路由器中转发表的长度</p>
<p>几个接口通过一个并不包含路由器的网络互连起来，形成一个<strong>子网</strong><code>subnet</code>。例如IP编制为某子网分配一个地址<code>223.1.1.0/24</code>，其中<code>/24</code>计法有时称为<strong>子网掩码</strong><code>network mask</code>，指示32比特中最左侧的24比特定义了子网地址</p>
<p>IP广播地址为<code>255.255.255.255</code>。当一台主机发送一个目的地址为<code>255.255.255.255</code>的数据报时，该报文会交付给同一个网络中的所有主机。路由器也会有选择地向领近的子网转发该报文（虽然它们通常不这样做）</p>
<h3 id="获取主机地址：动态主机配置协议"><a href="#获取主机地址：动态主机配置协议" class="headerlink" title="获取主机地址：动态主机配置协议"></a>获取主机地址：动态主机配置协议</h3><p>某组织一旦获得了一块地址，它就可为本组织内的主机与路由器接口逐个分配IP地址。主机地址也能手动配置，但这项任务目前更多的是使用<strong>动态主机配置协议</strong><code>Dynamic Host Configuration, DHCP</code>来完成。DHCP允许主机自动获取一个IP地址，或分配某主机一个<strong>临时IP地址</strong><code>temporary IP address</code>。除了分配主机IP地址外，DHCP还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器网址（常称为默认网关）与它的本地DNS服务器的地址</p>
<p>由于DHCP具有将主机连接进一个网络的网络相关方面的自动能力，故它又常被称为<strong>即插即用协议</strong><code>plug-and-play protocol</code>或<strong>零配置协议</strong><code>zeroconf</code></p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DHCP.png" class>

<p>DHCP四个步骤的过程：</p>
<p>1）DHCP服务器发现。一台新到达的主机的首要任务是发现一个要与其交互的DHCP服务器。这可通过使用<strong>DHCP发现报文</strong><code>DHCP discover message</code>来完成，客户在UDP分组向端口67发送该发送报文，使用广播目的地址<code>255.255.255.255</code>并使用“本主机”源IP地址<code>0.0.0.0</code>。DHCP客户将该IP地址传递给链路层，链路层然后将该帧广播到所有与该子网连接的节点</p>
<p>2）DHCP服务器提供。DHCP服务器收到一个DHCP发现报文时，用<strong>DHCP提供报文</strong><code>DHCP offer message</code>向客户做出响应，该报文向该子网的所有节点广播，仍然使用IP广播地址<code>255.255.255.255</code>。因为子网中可能存在几个DHCP服务器，该用户可从几个提供者间进行选择。每台服务器提供的报文包含有收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及<strong>IP地址租用期</strong><code>address lease time</code></p>
<p>3）DHCP请求。新到达的客户从一个或多个服务器中选择一个，并向选中的服务器提供用<strong>DHCP请求报文</strong><code>DHCP request message</code>进行响应，回显配置的的参数</p>
<p>4）DHPC ACK。服务器用<strong>DHCP ACK报文</strong><code>DHCP ACK message</code>对DHCP请求报文进行响应，证实所要求的参数</p>
<p>一旦客户收到DHCP ACK后，交互便完成了</p>
<h3 id="网络地址转换-Network-Address-Translation-NAT"><a href="#网络地址转换-Network-Address-Translation-NAT" class="headerlink" title="网络地址转换 Network Address Translation, NAT"></a>网络地址转换 Network Address Translation, NAT</h3><p>地址空间<code>10.0.0.0/8</code>是在[RFC 1918]中保留的三部分IP地址空间之一，这些地址用于家庭网络等<strong>专用网络</strong><code>private network</code>或<strong>具有专用地址的地域</strong><code>realm with private address</code>。具有专用地址的地域是指其地址仅对该网络中的设备有意义的网络。考虑有数十万家庭网络这样的事实，许多使用了相同地址空间<code>10.0.0.0/24</code>。在一个给定家庭网络中的设备能够使用<code>10.0.0.0/24</code>编址彼此发送分组。然而，转发到家庭网络之外进入更大的全球互联网的分组显然不能使用这些地址（或作为源地址，或作为目标地址），因为有数十万的网络使用着这块地址。这就是说，<code>10.0.0.0/24</code>地址仅在给定的网络中才有意义。但如果专用地址仅在给定的网络中才有意义的话，当向或从全球因特网发送或接收分组时如何处理编址问题呢，地址在何处才必须是唯一的呢？答案在于理解NAT</p>
<p>NAT使能路由器对于外界世界来说甚至不像一台路由器。相反NAT路由器对外界的行为就如同一个具有单一IP地址的单一设备。从本质上讲，NAT使能路由器对外界隐藏了家庭网络的细节。家庭网络计算机从何处得到其地址，路由器又是从何处得到它的单一IP地址呢？通常情况下，答案是相同的，即DHCP！路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间中的计算机提供地址</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/NAT.png" class>

<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>一个经常问的问题是：IPv5出了什么情况？人们最初预想ST-2协议将成为IPv5，但ST-2后来被舍弃了</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/IPv6format.png" class>

<p>在实践中已经得到广泛采用的IPv4到IPv6迁移的方法包括<strong>建隧道</strong><code>tunneling</code>。我们将两台IPv6路由器之间的中间IPv4路由器集合称为一个<strong>隧道</strong><code>tunnel</code>。借助于隧道，在隧道发送端的IPv6节点可将整个IPv6数据报放到一个IPv4数据报的数据（有效载荷）字段中。于是，该IPv4数据报的地址设为指向隧道接收端的IPv6节点，再发送给隧道中的第一个节点。隧道中间的IPv4路由器在它们之间为该数据报提供路由，就像对待其他数据报一样，完全不知道该IPv4数据报自身就含有一个完整的IPv6数据报。隧道接收端的IPv6节点最终收到该IPv4数据报，从中取出IPv6数据报，然后再为该IPv6数据报提供路由，就好像它是从一个直接相连的IPv6邻居那里接收到该IPv6数据报的一样</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/tunneling.png" class>

<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p><strong>路由选择算法</strong><code>routing algorithm</code>的一种分类方式是根据该算法是集中式还是分散式来划分</p>
<p><strong>集中路由选择算法</strong><code>centralized routing algorithm</code>用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有开销为输入，这就要求算法在真正开始计算前要以某种方式获得这些信息。具有全局状态信息的算法常被称作<strong>链路状态算法</strong><code>Link State, LS</code></p>
<p>在<strong>分散式路由选择算法</strong><code>decentralized routing algorithm</code>中，路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。相反，每个节点仅有与其直接相连链路的开销知识即可开始工作，然后通过迭代计算过程以及与相邻节点的信息交换逐渐计算出到达目的节点或一组目的节点的最低开销路径。<strong>距离向量算法</strong><code>Distance-Vector, DV</code>是分散式路由选择算法的一个例子</p>
<p>第二种广义分类方式是根据算法是静态的还是动态的进行分类。在<strong>静态路由选择算法</strong>·<code>static routing algorithm</code>中，路由随时间的变化非常缓慢，通常是人工进行调整。<strong>动态路由选择算法</strong><code>dynamic routing algorithm</code>随着网络流量负载或拓扑发生变化而改变路由选择路径</p>
<p>第三种分类方式是根据它是负载敏感的还是负载迟钝的进行划分。在<strong>负载敏感算法</strong><code>load-sensitive algorithm</code>中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。当今因特网路由选择算法（如RIP、OSPF和BGP）都是<strong>负载迟钝的</strong><code>load-insensitive</code>，因为某条链路的开销不明确地反映其当前（或最近）的拥塞水平</p>
<h2 id="链路状态算法"><a href="#链路状态算法" class="headerlink" title="链路状态算法"></a>链路状态算法</h2><p>链路状态算法的一个具体例子就是<code>Dijkstra</code>算法，通过运行该算法，每台路由器都将知道从自己出发到任意目的点的最优解，但若该算法是拥塞敏感的，网络中的路由选择可能会<strong>振荡</strong><code>Oscillation</code></p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/Oscillation.png" class>

<p>防止该振荡的一种解决方式是强制链路开销不依赖于所承载的流量，但这是一种不可接受的方案，因为路由选择的目标之一就是要避开高度拥塞的链路。另一种方案是确保并非所有的路由器都同时运行LS算法，因为我们希望即使路由器以相同周期运行LS算法，在每个节点上执行的时机也是不同的。有趣的是，研究发现因特网上的路由器能在它们之间进行自同步。这就是说，即使它们初始以同一周期但在不同时刻执行算法，算法执行时机最终会在路由器上变为同步并保持之。避免这种自同步的一种方法是，让每台路由器发送链路通告的时间随机化</p>
<h2 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h2><p>距离向量算法则是基于<code>Bellman-Ford</code>方程</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA1.png" class>

<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA2.png" class>

<p>该算法存在缺陷：当两路由器间链路开销发生变化（例如，开销增大）时，可能在网络中形成<strong>路由选择环路</strong><code>routing loop</code>，如下图所示</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA3.png" class>

<p>原本y到x开销为4，z经y到x开销为5.当(x, y)间链路开销突增至60时，我们期待的正确结果是：z通过开销为50的链路直接到达x，而y也通过z到达x，总开销为51.但实际上，y查询它的转发表，发现z到x开销为5（其实z正是通过y到达x的，但y不知道），于是y将其到x的路径改为先从y到z，再从z到x,总开销为6。设想有一个分组传至y路由器，其目的地址为x，则y将该分组发向z，z又传回给y…如此循环往复</p>
<p>一种称为<strong>毒性逆转</strong><code>poisoned reverse</code>的算法可以避免两个路由间可能的路由选择环路，其思想是，如果z是通过y到达x的，则z告诉y它到x的距离为无穷大，即使实际上并不是。如此一来，还是上图中的情形，当(x, y)间开销增至60时，y发现它直接到x开销为60，而若选择走z这条路开销则是无穷，它别无选择，只能是直接到达x。当y修改其转发表后将新的数据发往z，z此时发现通过y再到x还不如直达x划算，于是修改路由为直接到达x，z又将新的数据发往y，接着y发现通过z到x开销更小，于是转而选择通过z到x。这样，一切和我们期待的一致</p>
<p>但毒性逆转无法解决多个路由形成的环路</p>
<p>总之，LS算法与DV算法没有一个是明显的赢家，它们的确都在因特网中得到了应用</p>
<h2 id="因特网自治系统内部的路由选择：OSPF"><a href="#因特网自治系统内部的路由选择：OSPF" class="headerlink" title="因特网自治系统内部的路由选择：OSPF"></a>因特网自治系统内部的路由选择：OSPF</h2><p>之前的学习中，我们将网络只看作一个互联路由器的集合。从所有路由器执行相同的路由选择算法计算穿越整个网络的路由选择路径的意义上来说，一台路由器很难同另一台路由器区分开来，在实践中，该模型和这种一组执行同样路由选择算法的同质路由器集合的观点有点简单化，有两个重要原因：</p>
<p>1）规模。随着路由器数目规模变得很大，涉及路由选择信息的通信、计算和存储开销将高得不可实现</p>
<p>2）管理自治。因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器（如在自己的网络中运行它所选择的某种路由选择算法），或对外部隐藏其网络的内部组织面貌。理想情况下，一个组织应当按照自己的愿望运行和管理其网络，还要能将其网络与其他外部网络连接起来</p>
<p>这两个问题都可以通过路由器组织进<strong>自治系统</strong><code>Autonomous System, AS</code>来解决。在相同AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行的路由选择算法叫作<strong>自治内部路由选择协议</strong><code>intra-autonomous system routing protocol</code></p>
<p><strong>开放最短路优先</strong><code>OSPF</code>路由选择及其关系密切的协议IS-IS都广泛用于因特网的AS内部路由选择。ISPF中的开放<code>open</code>指路由选择协议规范是公众可用的，该协议使用洪泛链路状态信息和<code>Dijkstra</code>最低开销路径算法。使用OSPF，一台路由器构建了一幅关于整个自治系统的完整拓扑图，而各条链路开销是由网络管理员配置的。OSPF的优点包括：1）安全，2）多条相同开销的路径。当到达某目的地的多条路径具有相同的开销时，OSPF允许使用多条路径，3）对 单播和多播路由选择的综合支持，4）支持在单个AS中的层次结构</p>
<h2 id="ISP之间的路由选择：BGP"><a href="#ISP之间的路由选择：BGP" class="headerlink" title="ISP之间的路由选择：BGP"></a>ISP之间的路由选择：BGP</h2><p>OSPF是一个AS内部路由选择协议，而不同AS之间需要通过<strong>自治系统间路由选择协议</strong><code>inter-autonomous system routing protocol</code>进行协调。在因特网中，所有的AS运行相同的AS间路由选择协议，称为<strong>边界网关协议</strong><code>Broder Gateway Protocol, BGP</code>，BGP十分重要，正是这个协议将因特网中数以千计的ISP黏合起来。BGP是一种分布式和异步协议</p>
<p>当路由器通过BGP连接通告前缀时，它在前缀中包含一些<strong>BGP属性</strong> <code>BGP attribute</code>。用BGP术语来说，前缀及其属性称为<strong>路由</strong><code>route</code>。两个较为重要的属性是AS-PATH和NEXT-HOP。AS-PATH属性包含了通告已经通过的AS的列表，该AS将其ASN加入AS-PATH中现有列表。BGP路由器还使用AS-PATH属性来检测和防止通告环路；特别是，如果一台路由器在路径列表中看到包含了它自己的AS，它将拒绝该通告；NEXT-HOP是AS-PATH起始路由接口的IP地址。对于从AS1通过AS2到x的路由“AS2 AS3 x“，其属性NEXT-HOP是路由2a左边接口的IP地址。注意到NEXT-HOP属性<strong>不属于</strong>AS1的某路由器的IP地址；然而，包含该IP地址的子网直接连接到AS1</p>
<p>作为一种AS间的路由选择协议，BGP为每台路由器提供了一种完成以下任务的手段：1）从邻居AS获得前缀的可达性信息。特别是，BGP允许每个子网向因特网的其余部分通知它的存在；2）确定到该前缀的“最好的”路由</p>
<p>对于每个AS，每台路由器要么是一台<strong>网关路由器</strong><code>gateway router</code>，要么是一台<strong>内部路由器</strong><code>internel router</code></p>
<p><strong>热土豆路由选择</strong><code>hot potato routing</code>是一种较为简单的BGP路由选择算法。若一台路由器到达前缀x有两条BGP路由，使用热土豆路由选择，（从所有可能的路由中）选择的路由到开始该路由的NEXT-HOP路由器具有最小开销。假设开销定义为穿越的链路数，则该路由选择离它跳数最少的NEXT-HOP</p>
<p>在实践中，BGP使用了一种比热土豆路由选择算法更加复杂但却结合了其特点的算法，如果到相同的前缀有两条或多条路由，则顺序地调用下列消除规则直到余下一条路由：</p>
<p>1）路由被指派一个<strong>本地偏好</strong><code>local preference</code>值作为其属性之一（除了AS-PATH和NEXT-HOP以外）。本地偏好属性的值是一种策略决定，它完全取决于该AS的网络管理员。具有最高本地偏好值的路由将会被选择</p>
<p>2）从余下的路由中（所有都具有相同的最高本地偏好值），将选择具有最短AS-PATH的路由。如果该规则是路由选择的唯一规则，则BGP将使用距离向量算法决定路径，<strong>其中距离测度使用AS跳数而不是路由器跳数</strong></p>
<p>3）从余下的路由中（所有都具有相同的最高本地偏好值和相同的AS-PATH长度），使用热土豆选择，即选择具有最靠近NEXT-HOP路由器的路由</p>
<p>4）如果仍留下多条路由，该路由器使用BGP标识符来选择路由</p>
<p>教材用的英文第五版，我用的中文第七版，第七版后面还有一点内容，但我实在懒得打字了</p>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>为了透彻理解链路层以及它是如何与网络层关联的，我们考虑一个交通运输的类比例子。假设一个旅行计划为游客开辟从美国新泽西州的普林斯顿到瑞士洛桑的旅游路线。假定该旅行社认为对于游客而言最为便利的方案是：从普林斯顿乘豪华大轿车到JFK机场，然后乘飞机从JFK机场去日内瓦机场，最后乘火车从日内瓦机场到洛桑火车站。一旦该旅行社作了这3项预定，普林斯顿豪华大轿车公司将负责将游客从普林斯顿带到JFK，航空公司将负责将游客从JFK带到日内瓦，瑞士火车服务将负责将游客从日内瓦带到洛桑。该旅途中3段中的每一段都在两个“相邻”地点之间是“直达的”。注意到这3段运输是由不同的公司管理，使用了完全不同的运输方式（豪华大轿车、飞机和火车）。尽管运输方式不同，但它们都提供了将旅客从一个地点运输到相邻地点的基本服务。在这个运输类比中，一个游客好比一个数据报，每个运输区段好比一条链路，每种运输方式好比一种链路层协议，而该旅行社好比一个路由选择协议</p>
<p>链路层能够提供的<strong>可能</strong>服务包括：<strong>成帧</strong><code>framing</code>；链路接入。<strong>媒体访问控制</strong><code>Medium Access Control, MAC</code>协议规定了帧在链路上传输的规则；可靠交付；差错检测和纠正</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/networkPhysical.png" class>

<p>链路层的主体部分是在<strong>网络适配器</strong><code>network adapter</code>中实现的，网络适配器有时也称为<strong>网络接口卡</strong><code>Network Interface Card, NIC</code>。位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测等）的专用芯片</p>
<p>差错检测和纠正技术有：1）奇偶校验，包括使用单个<strong>奇偶检验位</strong><code>parity bit</code>和<strong>二维奇偶校验</strong><code>two-dimensional parity</code>；2）检验和方法；3）<strong>循环冗余检测</strong><code>Cyclic Redundancy Check, CRC</code><strong>编码</strong></p>
<p>如何协调多个发送和接收节点对一个共享广播信道的访问，这就是<strong>多路访问问题</strong><code>multiple access problem</code>，解决这个问题的协议即所谓<strong>多路访问协议</strong><code>multiple access protocol</code></p>
<p>因为所有节点都能传输帧，所以多个节点可能会同时传输帧。当发生这种情况时，所有节点同时接收到多个帧；这就是说，传输的帧在所有的接收方处<strong>碰撞</strong><code>collide</code>了。涉及此次碰撞的所有帧都丢失了，在碰撞时间间隔中的广播信道被浪费了</p>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>多年来以实现几十种多路访问协议，其中任意一种都可划分为3种类型之一：<strong>信道划分协议</strong><code>channel partitioning protocol</code>，<strong>随机接入协议</strong><code>random access protocol</code>和<strong>轮流协议</strong><code>taking-turns protocol</code></p>
<p>在理想情况下，对于速率为R bps的广播信道，多路访问协议应该具有以下所希望的特性：</p>
<p>1）当且仅当一个节点发送数据时，该节点具有R bps的吞吐量；</p>
<p>2）当有M个节点发送数据时，每个节点吞吐量为R/M bps。这不必要求M个节点中的每一个节点总是有R/M的瞬时速率，而是每个节点在一些适当定义的时间间隔内应该有R/M的平均传输速率</p>
<p>3）协议是分散的，这就是说不会因为某主节点故障而使整个系统崩溃</p>
<p>4）协议是简单的，使实现不昂贵</p>
<h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>时分多路复用<code>TDM</code></p>
<p>频分多路复用<code>FDM</code></p>
<p><strong>码分多址</strong><code>Code Division Multiple Access, CDMA</code></p>
<h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>时隙ALOHA</p>
<p>ALOHA</p>
<h4 id="载波侦听多路访问CSMA"><a href="#载波侦听多路访问CSMA" class="headerlink" title="载波侦听多路访问CSMA"></a>载波侦听多路访问<code>CSMA</code></h4><p>两个重要的规则：</p>
<p>1）说话之前先听。如果其他人正在说话，等到他们说完话为止。在网络领域中，这被称为<strong>载波侦听</strong><code>carrier sensing</code>，即一个节点在传输前先听信道。如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输</p>
<p>2）如果与他人同时开始说话，停止说话。在网络领域中，这被称为<strong>碰撞检测</strong><code>collision detection</code>，即当一个传输节点在传输时一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时传输”循环之前等待一段随机时间</p>
<p>这两个规则包含在<strong>载波侦听多路访问</strong><code>Carrier Sense Multiple Access, CSMA</code>和<strong>具有碰撞检测的CSMA</strong><code>CSMA  with Collision Detection, CSMA/CD</code>协议族中</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/CSMA.png" class>

<p>从图中可以看出，显然广播信道的端到端<strong>信道传播时延</strong><code>channel propagation delay</code>（信号从一个节点传播到另一个节点所花费的时间）在决定其性能方面起着关键的作用。该传播时延越长，载波侦听节点不能侦听到网络中另一个节点已经开始传输的机会就越大。如果一个节点开始传播后发送碰撞，其实此次传播已经失败，将剩余数据传完没有意义，即使中止才是上策，这便是具有CSMA/CD所作改进</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/CSMA_CD.png" class>

<h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><p><strong>轮询协议</strong><code>polling protocol</code></p>
<p><strong>令牌传递协议</strong><code>token-passing protocol</code></p>
<h2 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h2><p>链路层地址有各种不同的称呼：<strong>LAN地址</strong><code>LAN address</code>、<strong>物理地址</strong><code>physical address</code>或<strong>MAC地址</strong><code>MAC address</code></p>
<p>适配器的MAC地址具有扁平结构（这与层次结构相反），而且不论适配器到哪里用都不会发送变化</p>
<p>因为存在网络层地址（例如，因特网的IP地址）和链路层地址（即MAC地址），所以需要在它们之间进行转换。对于因特网而言，这是<strong>地址解析协议</strong><code>Address Resolution Protocol, ARP</code></p>
<p>对路由器的每个接口，（在路由器中）也有一个ARP模块，一个IP地址</p>
<p><strong>注意，链路层交换机是没有MAC地址的</strong></p>
<p>交换机是<strong>自学习</strong><code>self-learning</code>的，是<strong>即插即用设备</strong><code>plug-and-play device</code></p>
<p>剩下的感觉也不怎么考，杨老师的PPT做得太好了。。。甚至感觉我的笔记都没啥太大必要，直接看PPT就好。。。。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本博客中所有图片均来自杨频老师《计算机网络》PPT</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>特别感谢网安学院杨频教授授权我使用其PPT。杨老师的PPT重点突出且格式优美，对我对计算机网络的学习帮助巨大，再次感谢杨老师！</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/21/%E7%AC%94%E8%AE%B0-C++/" rel="prev" title="C++笔记">
                  <i class="fa fa-chevron-left"></i> C++笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/12/06/%E7%AC%94%E8%AE%B0-EffectiveCpp/" rel="next" title="笔记-Effective C++">
                  笔记-Effective C++ <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FEZ</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">716k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:51</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
