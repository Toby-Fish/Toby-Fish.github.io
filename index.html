<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="FEZ的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="FEZ的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FEZ">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>FEZ的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7035c3f4ba1040e0d1972d11a3943ebb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">FEZ的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FEZ"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">FEZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/%E4%B8%BB%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/%E4%B8%BB%E9%A1%B5/" class="post-title-link" itemprop="url">主页</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-01 17:21:23" itemprop="dateCreated datePublished" datetime="2020-12-01T17:21:23+08:00">2020-12-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-24 22:37:45" itemprop="dateModified" datetime="2021-12-24T22:37:45+08:00">2021-12-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%BB%E9%A1%B5/" itemprop="url" rel="index"><span itemprop="name">主页</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>813</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>欢迎访问我的博客！</p>
<p>我计划于此分享有趣的东西，例如新学的知识、对某些问题的心得或是解决难题的思路等等。现在这个博客还很简陋，我会持续更新，将它做得更好，如果你想了解关于我的更多欢迎前往<a target="_blank" rel="noopener" href="https://github.com/Toby-Fish">我的GitHub个人主页</a>！</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/12/01/%E4%B8%BB%E9%A1%B5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/24/%E7%AC%94%E8%AE%B0-UnixLinux%E5%A4%A7%E5%AD%A6%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/24/%E7%AC%94%E8%AE%B0-UnixLinux%E5%A4%A7%E5%AD%A6%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">笔记-UnixLinux大学教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-24 22:33:58" itemprop="dateCreated datePublished" datetime="2021-12-24T22:33:58+08:00">2021-12-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-29 15:31:39" itemprop="dateModified" datetime="2021-12-29T15:31:39+08:00">2021-12-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Unix键盘使用"><a href="#Unix键盘使用" class="headerlink" title="Unix键盘使用"></a>Unix键盘使用</h1><p>在键盘上，按下&lt;Return&gt;键或^M键（它们等价）可以发送一个CR码。按下&lt;Linefeed&gt;或者^J键可以发送一个LF码。CR为返回信号，LF码为换行信号。</p>
<h2 id="修饰键：-lt-Ctrl-gt-键"><a href="#修饰键：-lt-Ctrl-gt-键" class="headerlink" title="修饰键：&lt;Ctrl&gt;键"></a>修饰键：&lt;Ctrl&gt;键</h2><table>
<thead>
<tr>
<th align="center">erase</th>
<th align="center">kill</th>
<th align="center">werase</th>
<th align="center">rprnt</th>
<th align="center">flush</th>
<th align="center">lnext</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^H</td>
<td align="center">^U</td>
<td align="center">^W</td>
<td align="center">^R</td>
<td align="center">^O</td>
<td align="center">^V</td>
</tr>
<tr>
<td align="center">susp</td>
<td align="center">intr</td>
<td align="center">quit</td>
<td align="center">stop</td>
<td align="center">eof</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">^Z/^Y</td>
<td align="center">^C</td>
<td align="center">^\</td>
<td align="center">^S/^Q</td>
<td align="center">^D</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>erase删除最后一个键入的字符，werase删除最后一个键入的单词，而kill则删除整行。</p>
<h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><table>
<thead>
<tr>
<th>字符</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>{}</td>
<td>花括号</td>
<td>花括号扩展：生成一种字符模式</td>
</tr>
<tr>
<td>|</td>
<td>管道</td>
<td>命令行：创建一个管道线</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>命令行：重定向输入</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>命令行：重定向输出</td>
</tr>
<tr>
<td>()</td>
<td>圆括号</td>
<td>命令行：在子shell中运行命令</td>
</tr>
<tr>
<td>#</td>
<td>hash、pound</td>
<td>命令行：注释的开头，忽略该行的其余部分</td>
</tr>
<tr>
<td>;</td>
<td>分号</td>
<td>命令行：用于分隔多条命令</td>
</tr>
<tr>
<td>`</td>
<td>反引号</td>
<td>命令行：命令替换</td>
</tr>
<tr>
<td>~</td>
<td>波浪号</td>
<td>文件名扩展：插入home目录的名称</td>
</tr>
<tr>
<td>?</td>
<td>问号</td>
<td>文件名扩展：匹配任意一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>方括号</td>
<td>文件名扩展：与一组字符中的字符匹配</td>
</tr>
<tr>
<td>*</td>
<td>星号</td>
<td>文件名扩展：匹配0个或多个字符</td>
</tr>
<tr>
<td>!</td>
<td>bang</td>
<td>历史列表：事件标记</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>作业控制：在后台运行命令</td>
</tr>
<tr>
<td>\</td>
<td>反斜线</td>
<td>引用：下一个字符转义</td>
</tr>
<tr>
<td>‘</td>
<td>引号、单引号</td>
<td>引用：取消所有的替换</td>
</tr>
<tr>
<td>“</td>
<td>双引号</td>
<td>引用：取消大部分替换</td>
</tr>
<tr>
<td>{}</td>
<td>花括号</td>
<td>变量：确定变量名称的界限</td>
</tr>
<tr>
<td>$</td>
<td>美元符号</td>
<td>变量：用变量的值替换</td>
</tr>
<tr>
<td>&lt;Return&gt;</td>
<td>新行字符</td>
<td>空白符：标记一行结束</td>
</tr>
<tr>
<td>&lt;Tab&gt;</td>
<td>制表符</td>
<td>空白符：在命令行中分隔单词</td>
</tr>
<tr>
<td>&lt;Space&gt;</td>
<td>空格符</td>
<td>空白符：在命令行中分隔单词</td>
</tr>
</tbody></table>
<p>有时候，可能希望按字面上的含义使用元字符，而不使用其特殊的含义。例如，将分号作为分号使用，而不是一个命令分隔符。或者可能希望不按管道使用|（竖线）。在这些情况中，必须告诉shell按字面意义解释字符。这样做时，可以称其为<strong>引用</strong>字符。</p>
<p>字符的引用方法有三种：使用反斜线、使用一对单引号或者使用一对双引号。</p>
<p>引用元字符最直接的方法就是在元字符前面放一个反斜线（\）。这就告诉shell忽略反斜线之后的字符的任何特殊含义。例如：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo It <span class="keyword">is</span> warm <span class="keyword">and</span> sunny\; come <span class="keyword">over</span> <span class="keyword">and</span> visit</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们在分号前放了一个反斜线。如果没有这个反斜线，那么shell将把这个分号解释成一个元字符，从而假定了您输入了两条独立的命令：echo和come。</p>
<p>考虑下述指令：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">echo</span> <span class="keyword">It</span> is warm (<span class="keyword">and</span> sunny)<span class="comment">; come &amp; visit</span></span><br></pre></td></tr></table></figure>

<p>这条命令不能正确运行，因为命令中有四个元字符。我们当然可以用四个反斜线依次引用每个元字符，但这样得到的命令却不容易阅读，一个更好的方法是使用单引号引用一串字符：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;It is warm (<span class="name">and</span> sunny)<span class="comment">; come &amp; visit&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们将单引号之间的所有内容引用。当然，这包括所有的字符，而不仅仅是元字符，但是它不影响数字字母字符的显示。</p>
<p>大多数时候，反斜线和单引号引用已足够。但是，在有些情形中，使用双引号引用更加方便。有时候，可能希望在一个引用字符串中使用$字符，用来引用变量的值，例如，下述命令在尖括号中显示用户标识和终端类型：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> My userid is &lt;<span class="variable">$USER</span>&gt;; <span class="attribute">my</span> terminal is &lt;<span class="variable">$TERM</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这种形式的命令不能正常工作，因为元字符&lt;、;和&gt;拥有特殊的含义（$字符没有什么问题，我们希望它是元字符）。解决方法就是只引用那些我们希望取字面含义的元字符：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo My userid <span class="keyword">is</span> <span class="string">\&lt;$USER\&gt;\;</span> my terminal <span class="keyword">is</span> <span class="string">\&lt;$TERM\&gt;</span></span><br></pre></td></tr></table></figure>

<p>这条命令可行，但是它非常复杂。而如果使用单引号来取代反斜线：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;My userid is &lt;<span class="variable">$USER</span>&gt;; my terminal is &lt;<span class="variable">$TERM</span>&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样比较容易阅读，但它引用了所有的元字符，包括$。这意味着只能看到字面上的$USER和$TERM，而不能看到这两个变量的值。对于这种情况，可以使用双引号，因为这样所有的$元字符将保留它们特殊的含义。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My userid is &lt;<span class="variable">$USER</span>&gt;; my terminal is &lt;<span class="variable">$TERM</span>&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面是小结：</p>
<p>使用反引号引用单个字符（称为转义了这个字符）。</p>
<p>使用单引号引用一串字符。</p>
<p>使用双引号引用一串字符。但是保留$（美元）、`（反引号）和\（反斜线）的特殊含义。</p>
<p>从前面的讨论中可以看出，单引号比双引号的功能更为强大。基于这一原因，有时候称单引号为<strong>强引用</strong><code>strong quote</code>，双引号为<strong>弱引用</strong><code>weak quote</code>。实际上，反斜线是所有引用中最强的一个。反斜线可以引用任何东西，因此，如果单引号不起作用，可以试一试反斜线。例如，有一天您可能需要转义一个单引号：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Don<span class="string">\&#x27;</span> t <span class="keyword">let</span> gravity get you down</span><br></pre></td></tr></table></figure>

<p>反斜线功能如此强大，所以它甚至可以引用新行字符（花点时间好好想想这一点）。</p>
<p>假设在某行的末尾键入了\&lt;Return&gt;，这样将生成\字符后面跟新行字符。光标移动到下一行，但是由于新行字符失去了它特殊的含义，所以它并不是一行结束的信号。这意味着不管接下来键入什么字符都是上一行的继续。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo Tis <span class="keyword">is</span> a very, very long \</span><br><span class="line">line <span class="keyword">that</span> goes <span class="keyword">on</span> <span class="keyword">and</span> <span class="keyword">on</span> <span class="keyword">for</span> a \</span><br><span class="line">very, very long <span class="built_in">time</span>.</span><br></pre></td></tr></table></figure>



<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="以超级用户工作：su"><a href="#以超级用户工作：su" class="headerlink" title="以超级用户工作：su"></a>以超级用户工作：su</h2><p>su(substitute userid)命令允许您临时变成另一个用户标识。为此，只需在su命令后输入新的用户标识即可。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[harley]</span>$ su weedly</span><br><span class="line">Password:</span><br><span class="line"><span class="string">[weedly]</span>$</span><br></pre></td></tr></table></figure>

<p>当您结束weedly的工作时，您需要做的就是结束当前shell。输入exit命令就可以结束当前shell。一旦结束了新shell，您就会自动返回原来的shell，即用户标识harley。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[weedly]$ <span class="keyword">exit</span></span><br><span class="line">[harley]$ </span><br></pre></td></tr></table></figure>

<p>上述例子中，您将用户标识变成weedly，但是仍然在harley的环境下工作。如果希望同时变换用户标识和环境，则需要在su命令名称之后键入一个-（连字符）。注意，连字符的两边都有一个空格。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">su - weedly</span></span><br></pre></td></tr></table></figure>

<p>现在您在weedly的环境中以weedly的名义工作了。</p>
<p>为方便起见，如果su命令没有指定用户标识，那么默认的用户标识是<strong>root</strong>。因此，下述两个命令是等效的。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">su</span> <span class="string">-</span></span><br><span class="line"><span class="attr">su</span> <span class="string">- root</span></span><br></pre></td></tr></table></figure>

<h2 id="以超级用户执行一条单独的指令：sudo"><a href="#以超级用户执行一条单独的指令：sudo" class="headerlink" title="以超级用户执行一条单独的指令：sudo"></a>以超级用户执行一条单独的指令：sudo</h2><p>切换至超级用户的时间太长会非常危险，sudo(substitute the userid an do something)命令允许您以另一个用户标识执行一条单独的命令。和su命令一样，sudo命令的默认用户标识为<strong>root</strong>。因此，为了以超级用户执行一条具体的命令，只需：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">command</span></span><br></pre></td></tr></table></figure>

<h2 id="键映射：stty"><a href="#键映射：stty" class="headerlink" title="键映射：stty"></a>键映射：stty</h2><p>显示系统的键盘映射时，使用下述命令：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">stty -a</span></span><br></pre></td></tr></table></figure>

<p>stty是“set terminal”命令，-a意味着“显示所有的设置”。</p>
<table>
<thead>
<tr>
<th align="center">信号</th>
<th align="center">键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">erase</td>
<td align="center">Backspack / Delete</td>
<td align="center">删除键入的最后一个字符</td>
</tr>
<tr>
<td align="center">werase</td>
<td align="center">^W</td>
<td align="center">删除键入的最后一个单词</td>
</tr>
<tr>
<td align="center">kill</td>
<td align="center">^X/^U</td>
<td align="center">删除整行</td>
</tr>
<tr>
<td align="center">intr</td>
<td align="center">^C</td>
<td align="center">停止正在运行的程序</td>
</tr>
<tr>
<td align="center">quit</td>
<td align="center">^\</td>
<td align="center">停止程序并保存core文件</td>
</tr>
<tr>
<td align="center">start</td>
<td align="center">^Q</td>
<td align="center">重新启动屏幕显示</td>
</tr>
<tr>
<td align="center">eof</td>
<td align="center">^D</td>
<td align="center">指示已经没有数据</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如果希望修改键映射，只需键入stty，后面跟着信号的名称，然后是新的键赋值即可。例如，将kill键修改为^U的命令如下：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty <span class="keyword">kill</span> <span class="symbol">^U</span></span><br></pre></td></tr></table></figure>

<p>当在stty命令中使用带Ctrl的字符名时，不必键入大写字母。例如，下面两条命令都能正常工作：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stty <span class="keyword">kill</span> <span class="symbol">^u</span></span><br><span class="line">stty <span class="keyword">kill</span> <span class="symbol">^U</span></span><br></pre></td></tr></table></figure>

<h2 id="在系统中查找程序：which、type、whence"><a href="#在系统中查找程序：which、type、whence" class="headerlink" title="在系统中查找程序：which、type、whence"></a>在系统中查找程序：which、type、whence</h2><p>查找某个程序是否可用的一种精确方法就是使用which命令，只需在键入的which命令后跟一个或多个程序的名称即可，例如：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which <span class="built_in">date</span> less vi harley</span><br></pre></td></tr></table></figure>

<p>我的机器运行以上指令的输出为：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin/date</span><br><span class="line"><span class="regexp">/usr/</span>bin/less</span><br><span class="line"><span class="regexp">/usr/</span>bin/vi</span><br></pre></td></tr></table></figure>

<p>which没有找到名为harley的程序，因此没有任何输出</p>
<p>如果您使用的shell是Bash，那么which命令还有一个备用指令type，例如：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">date</span></span><br></pre></td></tr></table></figure>

<p>如果使用的是Korn shell，那么您可以使用whence命令：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whence <span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<p>type和whence命令有时候要比which命令显示更多的细节信息。这在特定的环境下很有用。但是，在实机应用上，还是which命令的应用最广泛。</p>
<h2 id="显示时间和日期：date"><a href="#显示时间和日期：date" class="headerlink" title="显示时间和日期：date"></a>显示时间和日期：date</h2><p>简单的输入：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<p>Unix将显示当前的时间和日期。下面是一个样本输出，注意Unix使用的是24小时制时钟。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fri Dec <span class="number">24</span> <span class="number">23</span>:<span class="number">35</span>:<span class="number">06</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<p>从本质上讲，Unix并没有运行在本地时间上。所有的Unix系统都使用协调世界时<code>Coordinated Universal Time, UTC</code>，它是格林威治标准时间<code>Greenwich Mean Time, GMT</code>的现代名称。Unix在需要时默默地在UTC和本地时区之间进行转换。本地时区的细节信息在安装Unix时指定。</p>
<p>有时候，查看UTC时间比较便利。为了显示UTC时间，只需使用：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -u</span><br></pre></td></tr></table></figure>

<h2 id="显示日历：cal"><a href="#显示日历：cal" class="headerlink" title="显示日历：cal"></a>显示日历：cal</h2><p>显示当前月份的日历时，可以输入：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cal</span></span><br></pre></td></tr></table></figure>

<p>显示某一年的日历时，需要指定年度。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal <span class="number">1949</span></span><br></pre></td></tr></table></figure>

<p>为了显示某个特点月份的日历，需要先指定月份，再指定年度。例如，显示1952年12月的日历的命令如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal <span class="number">12</span> <span class="number">1952</span></span><br></pre></td></tr></table></figure>

<p>如果输入的是：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>那么得到的是公元12年的日历。</p>
<p>如果不希望显示日期，只希望得到这一天是这一年中的第几天，只需在cal名称之后键入-j即可。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	cal -j <span class="number">12</span> <span class="number">2009</span></span><br><span class="line">	December <span class="number">2009</span></span><br><span class="line"> Su  Mo  Tu  We  Th  Fr  Sa</span><br><span class="line">        <span class="number">335</span> <span class="number">336</span> <span class="number">337</span> <span class="number">338</span> <span class="number">339</span></span><br><span class="line"><span class="number">340</span> <span class="number">341</span> <span class="number">342</span> <span class="number">343</span> <span class="number">344</span> <span class="number">345</span> <span class="number">346</span></span><br><span class="line"><span class="number">347</span> <span class="number">348</span> <span class="number">349</span> <span class="number">350</span> <span class="number">351</span> <span class="number">352</span> <span class="number">353</span></span><br><span class="line"><span class="number">354</span> <span class="number">355</span> <span class="number">356</span> <span class="number">357</span> <span class="number">358</span> <span class="number">359</span> <span class="number">360</span></span><br><span class="line"><span class="number">361</span> <span class="number">362</span> <span class="number">363</span> <span class="number">364</span> <span class="number">365</span></span><br></pre></td></tr></table></figure>

<h2 id="查看系统信息：uptime、hostname、uname"><a href="#查看系统信息：uptime、hostname、uname" class="headerlink" title="查看系统信息：uptime、hostname、uname"></a>查看系统信息：uptime、hostname、uname</h2><p><strong>uptime</strong>用来显示系统已经运行多长时间（也就是连续运行）的有关信息：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">uptime</span></span><br></pre></td></tr></table></figure>

<p>一些典型的输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">11</span>:<span class="number">10</span>AM up <span class="number">103</span> days, <span class="number">6</span>:<span class="number">13</span>, <span class="number">3</span> users,</span><br><span class="line">  <span class="attribute">load</span> averages: <span class="number">1</span>.<span class="number">90</span>, <span class="number">1</span>.<span class="number">49</span>, <span class="number">1</span>.<span class="number">38</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，系统已经运行了103天6小时13分钟，而且当前有3个用户标识登录。最后三个数字展现了一直等待执行的程序的数量，分别是之前1分钟、5分钟和15分钟的平均数。这些数字表示系统的负载。负载越高，系统所做的工作就越多。</p>
<p><strong>hostname</strong>命令用来查看计算机的名称。如果经常登录不止一台计算机，那么该命令非常管用。如果忘记了正在使用的是哪一个系统，则可以输入：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hostname</span></span><br></pre></td></tr></table></figure>

<p><strong>uname</strong>命令显示操作系统的名称。</p>
<h2 id="显示自己的信息：whoami"><a href="#显示自己的信息：whoami" class="headerlink" title="显示自己的信息：whoami"></a>显示自己的信息：whoami</h2><p><strong>whoami</strong>命令显示您登录使用的用户标识。如果您突然得了健忘症，忘记了自己的名字，那么whoami命令也许特别有用。如果您的系统上没有whoami命令，则可以尝试输入下面3个单独的单词：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">who am i</span></span><br></pre></td></tr></table></figure>

<h2 id="请求Unix提醒何时离开：leave"><a href="#请求Unix提醒何时离开：leave" class="headerlink" title="请求Unix提醒何时离开：leave"></a>请求Unix提醒何时离开：leave</h2><p>在计算机上工作时经常需要全神贯注，很容易忘记时间。为了帮助您及时完成其他事情，只需输入下述命令：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">leave</span></span><br></pre></td></tr></table></figure>

<p>leave将询问您一个时间：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">When</span> <span class="keyword">do</span> you have <span class="keyword">to</span> leave?</span><br></pre></td></tr></table></figure>

<p>以<em>hhmm</em>（先是小时，后是分钟）的格式输入您希望离开的时间。例如希望在10：33离开，可以输入1033。</p>
<p>时间输入既可以是12小时制也可以是24小时制。例如，1344意味着1：44PM。而如果输入的小时数小于等于12，那么leave假定时间位于接下来12小时内。例如，如果现在时间是8：00PM，而您输入的是855，那么leave将它解释为8：55PM，而不是8：55AM。</p>
<p>如果需要在特定的时间间隔之后离开，则可以输入一个＋（加号），后面跟着分钟数。例如，如果需要在15分钟之后离开，可以输入：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leave +<span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>确保不要在+字符之后留空格。</p>
<h2 id="内置计算器：bc"><a href="#内置计算器：bc" class="headerlink" title="内置计算器：bc"></a>内置计算器：bc</h2><p>如果您希望使用bc内置的数学函数库，那么在启动程序时需要使用-l(library)选项：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bc -l</span></span><br></pre></td></tr></table></figure>

<p>不希望使用bc时，可以通过按^D或输入quit命令。</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sqrt(x)</td>
<td align="center">x的平方根</td>
</tr>
<tr>
<td align="center">s(x)</td>
<td align="center">x的正弦：其中x的单位是弧度</td>
</tr>
<tr>
<td align="center">c(x)</td>
<td align="center">x的余弦：其中x的单位是弧度</td>
</tr>
<tr>
<td align="center">a(x)</td>
<td align="center">x的反正切：其中x的单位是弧度</td>
</tr>
<tr>
<td align="center">ln(x)</td>
<td align="center">x的自然对数</td>
</tr>
<tr>
<td align="center">j(n, x)</td>
<td align="center">x的n次整阶贝塞尔函数</td>
</tr>
</tbody></table>
<p>默认情况下，bc假定做整数运算。您可以设置一个标度因子，告诉bc您希望保留小数点后几位。例如，要保留小数点后面3位，可以输入：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scale</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>如果希望查看标度因子的值，只需简单输入：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">scale</span></span><br></pre></td></tr></table></figure>

<p>bc允许设置并使用变量。变量由变量名和值组成。在bc中，变量名由一个小写字母构成。也就是说，bc中共有26个变量，从a到z（一定确保<strong>不要使用</strong>大写字母，当使用基时才使用它们——参见下面）。</p>
<p>您可以使用等号设置变量的值。例如，将变量x的值设置为100，可以输入：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>显示变量的值，只需输入变量名，例如：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，在变量没有赋值之前，bc假定所有变量的值为0。</p>
<p>一般情况下，bc计算时使用10作为基。但是，有时候您可能需要使用另一种基进行计算。bc允许对输入和输出指定不同的基。具体操作时，需要设置两个特殊的变量：<strong>ibase</strong>是用于输入的基；<strong>obase</strong>是用于输出的基。</p>
<p>例如，如果希望以基16显示答案，可以输入：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">obase</span>=<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>如果希望以基8输入数字，则需要使用：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ibase</span>=<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>对于大于或等于10的基值，bc分别使用大写字母A、B、C、D、E、F表示值10、11、12、13、14和15.记住一定要使用大写字母，如果使用了小写字母，那么bc将会认为它是变量，从而使结果出错。</p>
<p>为方便起见，无论设置的输入基是什么，都可以使用这些大写字母。例如，即使现在使用的基是10，表达式A+1的值也是11。</p>
<p>和其他变量一样，直接输入ibase和obase自身就可以获得它们的当前值：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ibase</span>; <span class="built_in">obase</span></span><br></pre></td></tr></table></figure>

<p>但是，一定要小心。因为一旦设置了obase的值，所有的输出都将以这个基进行显示，显示的值可能会对您产生麻烦。例如，如果您输入：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">obase</span>=<span class="number">16</span></span><br><span class="line"><span class="built_in">obase</span></span><br></pre></td></tr></table></figure>

<p>那么您将看到：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这是因为此时所有的输出都以基16显示，而在基16中，值“16”就表示为10。</p>
<p>同理，一旦修改了ibase，在输入时也必须特别小心。例如，假设您设置了：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ibase</span>=<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>现在希望将obase设置为基10，因此您输入：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">obase</span>=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>但是，您忘了现在的输入基是16，而10在基16中其实是“16”。因此，obase还是被设置成基16。</p>
<p>为了避免出现这样的错误，可以使用字母A到F，无论ibase的值是多少，它们仍然是原来的值。因此，如果事情出现了混乱，您总可以这样重新设置基：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">obase</span>=A<span class="comment">; ibase=A</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是Unix手册？man"><a href="#什么是Unix手册？man" class="headerlink" title="什么是Unix手册？man"></a>什么是Unix手册？man</h2><p>下面准备讨论的命令是针对less分页程序的，因为大多数Unix系统使用它。如果man命令使用的是more或者pg，那么为了获得该特定分页程序的帮助摘要信息，您也只需按下h键。</p>
<table>
<thead>
<tr>
<th align="left">通用命令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">q</td>
<td>退出</td>
</tr>
<tr>
<td align="left">h</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td align="left"><strong>阅读说明书页</strong></td>
<td></td>
</tr>
<tr>
<td align="left">&lt;Sapce&gt;</td>
<td>显示下一屏</td>
</tr>
<tr>
<td align="left">&lt;PageDown&gt;</td>
<td>显示下一屏</td>
</tr>
<tr>
<td align="left">f</td>
<td>显示下一屏</td>
</tr>
<tr>
<td align="left">&lt;PageUp&gt;</td>
<td>显示上一屏</td>
</tr>
<tr>
<td align="left">b</td>
<td>显示上一屏</td>
</tr>
<tr>
<td align="left"><strong>搜索</strong></td>
<td></td>
</tr>
<tr>
<td align="left">/pattern</td>
<td>向下搜索特定的模式</td>
</tr>
<tr>
<td align="left">?pattern</td>
<td>向上搜索特定的模式</td>
</tr>
<tr>
<td align="left">/</td>
<td>向下搜索上一模式</td>
</tr>
<tr>
<td align="left">n</td>
<td>向下搜索上一模式</td>
</tr>
<tr>
<td align="left">?</td>
<td>向上搜索上一模式</td>
</tr>
<tr>
<td align="left">N</td>
<td>向上搜索上一模式</td>
</tr>
<tr>
<td align="left"><strong>在说明书页中移动</strong></td>
<td></td>
</tr>
<tr>
<td align="left">&lt;Return&gt;</td>
<td>向下移一行</td>
</tr>
<tr>
<td align="left">&lt;Down&gt;</td>
<td>向下移一行</td>
</tr>
<tr>
<td align="left">&lt;Up&gt;</td>
<td>向上移一行</td>
</tr>
<tr>
<td align="left">g(go to top)</td>
<td>移到页的顶部</td>
</tr>
<tr>
<td align="left">G(go to bottom)</td>
<td>移到页的底部</td>
</tr>
</tbody></table>
<p>当阅读说明书页时，如果您键入一个!（感叹号），就可以在它之后键入一条shell命令。man程序将把这条命令发送给shell，而shell将运行这个命令。当命令结束后，可以按下&lt;Return&gt;键返回到man程序中。</p>
<h2 id="一种快速查询命令作用的方法：whatis"><a href="#一种快速查询命令作用的方法：whatis" class="headerlink" title="一种快速查询命令作用的方法：whatis"></a>一种快速查询命令作用的方法：whatis</h2><p>当输入man命令时，Unix将显示整个手册页。但有时候，您可能只对一个简要描述感兴趣。在这种情况下，还有另外一种方法。</p>
<p>说明书页的Name节中包含一行描述。如果只想看这一行内容，可以键入man -f，后面跟一个或者多个命令的名称。例如：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -f <span class="built_in">time</span> <span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<p>在man命令的这种形式中，-f称为一个选项，代表单词“files”。每个说明书页都存储在一个单独的文件中。当使用-f选项时，就是告诉man查找哪些文件。</p>
<p>为了方便起见，可以使用命令whatis来取代man -f。例如，如果想显示时间，但是不能确定是使用time命令还是date命令，就可以输入下面两条命令中的任意一条：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whatis <span class="built_in">time</span> <span class="built_in">date</span></span><br><span class="line">man -f <span class="built_in">time</span> <span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<p>您将看到类似下面的显示信息：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time (7)             - overview of time <span class="keyword">and</span> timers</span><br><span class="line">time (3am)           - time functions <span class="keyword">for</span> gawk</span><br><span class="line">time (1)             - <span class="builtin-name">run</span> programs <span class="keyword">and</span> summarize<span class="built_in"> system resource </span>usage</span><br><span class="line">time (2)             - <span class="builtin-name">get</span> time <span class="keyword">in</span> seconds</span><br><span class="line">date (1)             - <span class="builtin-name">print</span> <span class="keyword">or</span> <span class="builtin-name">set</span> the<span class="built_in"> system </span>date <span class="keyword">and</span> time</span><br></pre></td></tr></table></figure>

<p>第1、2、4行不是指向第1节的，可以忽略这三行。查看第3、5行，就可以知道您需要使用的命令是date。</p>
<p>众所周知，在输入man命令时，可以指定一个特定的节号（例如man 1 date)。至于man -f或者whatis命令，就不能再指定具体的节号。Unix总是搜索整个手册。因此，查找手册包含什么内容最好输入：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whatis <span class="built_in">int</span>ro</span><br></pre></td></tr></table></figure>

<p>这样将会显示每个intro页的简要说明，例如：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intro (1)            - introduction <span class="keyword">to</span><span class="built_in"> user </span>commands</span><br><span class="line">intro (2)            - introduction <span class="keyword">to</span><span class="built_in"> system </span>calls</span><br><span class="line">intro (3)            - introduction <span class="keyword">to</span> library functions</span><br><span class="line">intro (4)            - introduction <span class="keyword">to</span> special files</span><br><span class="line">intro (5)            - introduction <span class="keyword">to</span> file formats <span class="keyword">and</span> filesystems</span><br><span class="line">intro (6)            - introduction <span class="keyword">to</span> games</span><br><span class="line">intro (7)            - introduction <span class="keyword">to</span> overview <span class="keyword">and</span> miscellany section</span><br><span class="line">intro (8)            - introduction <span class="keyword">to</span> administration <span class="keyword">and</span> privileged commands</span><br></pre></td></tr></table></figure>

<h2 id="搜索命令：apropos"><a href="#搜索命令：apropos" class="headerlink" title="搜索命令：apropos"></a>搜索命令：apropos</h2><p>当希望学习某条具体的命令时，可以使用man来显示该命令的说明书页。但是，如果您知道想做什么，但是却不能确定使用哪条命令，该怎么办呢？</p>
<p>解决方法就是使用带有-k选项的man命令。这样将搜索NAME节中包含特定关键字的命令（字母k代表“keyword”）。例如，假如您希望查找手册中与手册自身相关的所有条目，则可以输入：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">man -k manual</span></span><br></pre></td></tr></table></figure>

<p>为了方便起见，可以使用单个单词apropos待替man -k：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apropos manual</span></span><br></pre></td></tr></table></figure>

<p>apropos命令搜索所有的单行命令描述，查找那些包含有指定字符串的描述。为了使该命令的功能更强大，在该命令中Unix不区分大小写字母。下面是上例的一些示例输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aclocal-1.16 (1)     -<span class="built_in"> manual page </span><span class="keyword">for</span> aclocal 1.16.1</span><br><span class="line">apropos (1)          - search the<span class="built_in"> manual page </span>names <span class="keyword">and</span> descriptions</span><br><span class="line">automake (1)         -<span class="built_in"> manual page </span><span class="keyword">for</span> automake 1.16.1</span><br><span class="line">automake-1.16 (1)    -<span class="built_in"> manual page </span><span class="keyword">for</span> automake 1.16.1</span><br><span class="line">catman (8)           - create <span class="keyword">or</span> update the pre-formatted<span class="built_in"> manual </span>pages</span><br><span class="line">man (1)              - an<span class="built_in"> interface </span><span class="keyword">to</span> the<span class="built_in"> system </span>reference manuals</span><br><span class="line">man-recode (1)       - convert<span class="built_in"> manual </span>pages <span class="keyword">to</span> another encoding</span><br><span class="line">manconv (1)          - convert<span class="built_in"> manual page </span><span class="keyword">from</span> one encoding <span class="keyword">to</span> another</span><br><span class="line">mandb (8)            - create <span class="keyword">or</span> update the<span class="built_in"> manual page </span>index caches</span><br><span class="line">manpath (1)          - determine search path <span class="keyword">for</span><span class="built_in"> manual </span>pages</span><br><span class="line">manual_user_enter_context (3) - determine SELinux context(s) <span class="keyword">for</span><span class="built_in"> user </span>sessions</span><br><span class="line">qemu-qmp-ref (7)     - QEMU QMP Reference Manual</span><br><span class="line">whatis (1)           - display one-line<span class="built_in"> manual page </span>descriptions</span><br><span class="line">whereis (1)          - locate the binary, source, <span class="keyword">and</span><span class="built_in"> manual page </span>files <span class="keyword">for</span> a command</span><br></pre></td></tr></table></figure>

<h2 id="Info系统"><a href="#Info系统" class="headerlink" title="Info系统"></a>Info系统</h2><p>Info系统是一个联机帮助系统，独立于Unix手册，用来记录GNU实用工具。因为许多类型的Unix——包括几乎所有的Linux系统，都使用GNU实用工具，所以大多数人发现了解如何同时使用联机手册和Info非常有用。</p>
<p>从表面上看，Info与联机手册有点相似。信息存储在文件中，每个文件一个主题，这与说明书页相似。这些文件称为Info文件，而且要阅读它们时，需要使用info程序。为此，只需键入info，后面跟着命令的名称即可。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">date</span></span><br><span class="line"><span class="built_in">info</span> <span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<p>如果不能确定希望学习哪条命令，或者您希望浏览系统，则可以输入info命令本身：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">info</span></span><br></pre></td></tr></table></figure>

<p>当以这种方式启动Info时，它显示一个称为<strong>目录节点</strong><code>Directory Node</code>的特殊节点。目录节点包含主要主题的列表，因此可以认为它是整个Info系统的主菜单。</p>
<p>在Info系统中有许多命令可以使用，下图总结了一些最重要的命令。</p>
<table>
<thead>
<tr>
<th>通用命令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>h</td>
<td>启动帮助向导</td>
</tr>
<tr>
<td>?</td>
<td>显示命令摘要列表</td>
</tr>
<tr>
<td><strong>阅读节点</strong></td>
<td></td>
</tr>
<tr>
<td>&lt;PageDown&gt;</td>
<td>显示下一屏</td>
</tr>
<tr>
<td>&lt;Space&gt;</td>
<td>显示下一屏</td>
</tr>
<tr>
<td>&lt;Space&gt;</td>
<td>（在节点底部时）跳转到下一个节点</td>
</tr>
<tr>
<td>&lt;PageUp&gt;</td>
<td>显示上一屏</td>
</tr>
<tr>
<td>&lt;Backspace&gt;</td>
<td>显示上一屏</td>
</tr>
<tr>
<td>&lt;Delete&gt;</td>
<td>显示上一屏</td>
</tr>
<tr>
<td>&lt;Backspace&gt;</td>
<td>（在节点顶部时）跳转到上一个节点</td>
</tr>
<tr>
<td>&lt;Delete&gt;</td>
<td>（在节点顶部时）跳转到上一个节点</td>
</tr>
<tr>
<td><strong>在节点中移动</strong></td>
<td></td>
</tr>
<tr>
<td>b</td>
<td>跳转到当前节点的开头</td>
</tr>
<tr>
<td>&lt;Up&gt;</td>
<td>将光标向上移动一行</td>
</tr>
<tr>
<td>&lt;Down&gt;</td>
<td>将光标向下移动一行</td>
</tr>
<tr>
<td>&lt;Right&gt;</td>
<td>将光标向右移动一个位置</td>
</tr>
<tr>
<td>&lt;Left&gt;</td>
<td>将光标向左移动一个位置</td>
</tr>
<tr>
<td><strong>在同一个文件中从一个节点跳转到另一个节点</strong></td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>跳转到同一个文件的下一个节点</td>
</tr>
<tr>
<td>p</td>
<td>跳转到同一个文件的上一个节点</td>
</tr>
<tr>
<td>t</td>
<td>跳转到顶节点（Top Node，文件中的第一个节点）</td>
</tr>
<tr>
<td><strong>从一个文件跳转到另一个文件</strong></td>
<td></td>
</tr>
<tr>
<td>&lt;Tab&gt;</td>
<td>将光标移动到下一个链接上</td>
</tr>
<tr>
<td>&lt;Shift&gt;-&lt;Tab&gt;</td>
<td>将光标移动到上一个链接上</td>
</tr>
<tr>
<td>&lt;Return&gt;</td>
<td>到达链接指向的新节点或文件</td>
</tr>
<tr>
<td>l</td>
<td>跳转到上一个（刚才观看的）节点</td>
</tr>
<tr>
<td>d</td>
<td>跳转到目录节点（主菜单）</td>
</tr>
</tbody></table>
<h2 id="显示环境变量：env、printenv"><a href="#显示环境变量：env、printenv" class="headerlink" title="显示环境变量：env、printenv"></a>显示环境变量：env、printenv</h2><p>为了显示默认变量，可以使用命令env：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">env</span></span><br></pre></td></tr></table></figure>

<p>在许多系统上，还有另外一个命令可以是用，这个命令是printenv：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">printenv</span></span><br></pre></td></tr></table></figure>

<p>名称printenv代表“print environment variables”。</p>
<h2 id="显示shell变量：set"><a href="#显示shell变量：set" class="headerlink" title="显示shell变量：set"></a>显示shell变量：set</h2><p>使用不带选项或者参数的set命令可以显示所有的shell变量以及它们的值：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span></span><br></pre></td></tr></table></figure>

<h2 id="显示及使用变量的值：echo、print"><a href="#显示及使用变量的值：echo、print" class="headerlink" title="显示及使用变量的值：echo、print"></a>显示及使用变量的值：echo、print</h2><p>echo命令的任务就是显示赋予它的任何对象的值。为了显示一个变量的值，需要使用一个$（美元符号）字符。后面跟着用花括号括起来的变量名。例如，显示变量TERM的值，可以输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;TERM&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果没有歧义，也可以省略花括号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$TERM</span></span><br></pre></td></tr></table></figure>

<p>在shell中，一些标点符号字符称为“元字符”，它们拥有特殊的含义。为了防止shell解释元字符，需要将元字符包含在双引号中。这就告诉shell照字面意义接受字符。例如，为了显示尖括号中的TERM值。您可以输入下述命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo The terminal<span class="built_in"> type </span>is &lt;<span class="variable">$TERM</span>&gt;.</span><br></pre></td></tr></table></figure>

<p>但是，&lt;和&gt;字符是元字符，表示“重定向”，所以该命令不能正常运行。为此，您需要使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The terminal type is &lt;<span class="variable">$TERM</span>&gt;.&quot;</span></span><br></pre></td></tr></table></figure>

<p>所有的shell都允许使用echo命令显示文本和变量。至于Korn shell，还可以使用print命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;The terminal type is <span class="variable">$TERM</span>.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Bourne-shell家族使用变量：export、unset"><a href="#Bourne-shell家族使用变量：export、unset" class="headerlink" title="Bourne shell家族使用变量：export、unset"></a>Bourne shell家族使用变量：export、unset</h2><p>对于Bourne shell家族，创建变量非常简单。所需做的全部事情就是键入一个名称，后跟一个=（等号）字符，再后跟一个值。变量的值必须是字符串。创建变量的语法为：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NAME</span>=<span class="keyword">value</span></span><br></pre></td></tr></table></figure>

<p>我们创建一个命名为HARLEY的变量，并将值cool赋给它：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HARLEY</span>=<span class="string">&quot;a cool boy&quot;</span></span><br></pre></td></tr></table></figure>

<p>在Bourne shell家族中，每个新变量都自动地被设置成shell变量。使用export命令可以将变量导出到环境中。</p>
<p>因此，此时HARLEY只是一个shell变量。如果启动一个新shell或者运行一条命令，则新进程并不能访问HARLEY，因为它还不是环境变量。下面将HARLEY导出到环境中：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> HARLEY</span><br></pre></td></tr></table></figure>

<p>现在HARLEY变量既是shell变量又是环境变量了。如果这时再启动一个新shell或者运行一条命令，那么它们就可以访问HARLEY。</p>
<p>export命令实际上允许同时设置变量并导出到环境中。该命令的语法为：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> NAME[=value]<span class="built_in">..</span></span><br></pre></td></tr></table></figure>

<p>下面举一个简单的例子：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PAGER</span>=less</span><br></pre></td></tr></table></figure>

<p>正如前面所述，当创建变量时，我们称这是在设置变量。当删除变量时，我们称这是在<strong>复位</strong><code>unset</code>变量。变量极少需要复位，但是如果需要的话，则可以使用unset命令。该命令的语法比较简单：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">unset</span></span> NAME..</span><br></pre></td></tr></table></figure>

<p>下面举例说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> HARLEY WEEDLY</span><br></pre></td></tr></table></figure>

<h2 id="C-shell家族使用变量：setenv、unsetenv、set、unset"><a href="#C-shell家族使用变量：setenv、unsetenv、set、unset" class="headerlink" title="C-shell家族使用变量：setenv、unsetenv、set、unset"></a>C-shell家族使用变量：setenv、unsetenv、set、unset</h2><p>在C-shell家族中，使用setenv和unsetenv命令可以设置（创建）或复位（删除）环境变量。设置或复位shell变量时，需要使用set和unset命令。</p>
<p>setenv命令的语法如下所示：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute"><span class="nomarkup">setenv</span></span> NAME<span class="meta"> [value]</span></span><br></pre></td></tr></table></figure>

<p>注意，该命令中未使用=（等号）字符。</p>
<h2 id="shell选项：set-o、set-o"><a href="#shell选项：set-o、set-o" class="headerlink" title="shell选项：set -o、set +o"></a>shell选项：set -o、set +o</h2><p>shell选项就像on/off开关一样。当打开一个选项时，就说<strong>设置</strong>了这个选项。这将告诉shell以某种方式运行。当关闭这个选项时，就说<strong>复位</strong>了这个选项。这也就是告诉shell停止以这种方式运行。</p>
<p>要设置一个选项，可以使用：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> -o <span class="keyword">option</span></span><br></pre></td></tr></table></figure>

<p>要复位一个选项，可以使用：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> +o <span class="keyword">option</span></span><br></pre></td></tr></table></figure>

<p>例如，假设shell正在运行，您希望设置monitor选项，则可以使用：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> -o <span class="comment">monitor</span></span><br></pre></td></tr></table></figure>

<p>为了复位monitor，可以使用：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> +o <span class="comment">monitor</span></span><br></pre></td></tr></table></figure>

<p>要显示shell选项的当前值，可以使用set -o或set +o命令本身：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> -o</span><br><span class="line"><span class="builtin-name">set</span> +o</span><br></pre></td></tr></table></figure>

<h2 id="shell内置命令：type"><a href="#shell内置命令：type" class="headerlink" title="shell内置命令：type"></a>shell内置命令：type</h2><p>一些指令在shell的内部，这意味着shell可以直接解释它们。这些指令是<strong>内部命令</strong>，通常称为<strong>内置命令</strong><code>builtin command</code>。其他所有命令是<strong>外部命令</strong>。</p>
<p>一种查看某条命令是不是内置指令的快捷方式就是使用type命令。该命令的语法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">command</span>...</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">date</span> <span class="built_in">time</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<p>该命令的准确输出依赖于所使用的shell。例如，下面是在我系统上的输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> is /usr/bin/<span class="built_in">date</span></span><br><span class="line"><span class="built_in">time</span> is <span class="keyword">a</span> <span class="built_in">shell</span> keyword</span><br><span class="line"><span class="built_in">set</span> is <span class="keyword">a</span> <span class="built_in">shell</span> builtin</span><br></pre></td></tr></table></figure>

<p>一些Unix/Linux系统对于内置命令拥有独立的说明书页。使用apropos命令可以查看系统是不是属于这种情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apropos <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure>

<p>Linux还有一个help命令，可以以若干种方式显示builtin说明书页的信息。该命令的语法为：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">help</span> [-s] [<span class="keyword">command</span>.<span class="string">..</span>]</span><br></pre></td></tr></table></figure>

<p>其中command是命令的名称。</p>
<p>开始时，可以通过输入help命令本身显示一个所有内置命令的摘要列表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">help</span></span><br><span class="line"><span class="keyword">help</span> | <span class="keyword">less</span></span><br></pre></td></tr></table></figure>

<p>另外还可以使用help命令显示一条或多条具体命令的信息，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">pwd</span> <span class="built_in">history</span> <span class="built_in">kill</span> <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>可以看出，help本事就是一条内置命令。</p>
<p>最后，如果只希望查看某条命令的语法，可以使用-s（syntax，语法）选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> -s <span class="built_in">help</span></span><br><span class="line"><span class="built_in">help</span> -s <span class="built_in">pwd</span> <span class="built_in">history</span> <span class="built_in">kill</span></span><br></pre></td></tr></table></figure>

<h2 id="历史列表：fc、history"><a href="#历史列表：fc、history" class="headerlink" title="历史列表：fc、history"></a>历史列表：fc、history</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/06/%E7%AC%94%E8%AE%B0-EffectiveCpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/06/%E7%AC%94%E8%AE%B0-EffectiveCpp/" class="post-title-link" itemprop="url">笔记-Effective C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-06 18:40:26" itemprop="dateCreated datePublished" datetime="2021-12-06T18:40:26+08:00">2021-12-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-23 16:52:39" itemprop="dateModified" datetime="2021-12-23T16:52:39+08:00">2021-12-23</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>绝大多数情况下应该用<code>expliccit</code>关键字修饰构造函数，我们往往不期望构造函数被用于隐式类型转换</p>
<p>将二元操作符函数如<code>operator==</code>和<code>operator*</code>的两个参数命名为<code>lhs</code>和<code>rhs</code>，分别意为<code>left-hand-side</code>和<code>right-hand-side</code></p>
<p>将指向一个T型对象的指针命名为pt，意为<code>pointer to T</code>，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw;					<span class="comment">// pw = &quot;ptr to Widget&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>;</span></span><br><span class="line">Airplane* pa;				<span class="comment">// pa = &quot;ptr to Airplane&quot; </span></span><br></pre></td></tr></table></figure>

<p>对references类似，<code>rw</code>可能是个<code>reference to Widget</code>，<code>ra</code>则是个<code>reference to Airplane</code></p>
<h1 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1.让自己习惯C++"></a>1.让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><p>这个条款提供的视角很有意思，C++威力巨大，但涉及的东西太多太杂，融合了太多东西。将C++视为一个由相关次语言<code>sublanguage</code>组成的联邦而非单一语言或许对认识C++有所帮助</p>
<p>主要的四个次语言：C, Object-Oriented C++，Template C++, STL。当从一个次语言切换到另一个次语言时，所遵从的高效编程策略也许会随之改变。例如对内置（C-like）类型而言pass by value通常比pass by reference更高效，但当从C part of C++移往Object-Oriented C++时，对于由用户定义的类型，pass by reference to const往往比pass by value更高效</p>
<p>C++高效编程守则视状况而变化，取绝于你使用C++的哪一部分</p>
<h2 id="条款02：尽量以const-enum-inline替换-define"><a href="#条款02：尽量以const-enum-inline替换-define" class="headerlink" title="条款02：尽量以const, enum, inline替换 #define"></a>条款02：尽量以const, enum, inline替换 #define</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line">替换为</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f( (a) &gt; (b) ? (a) : (b) )</span></span><br><span class="line">替换为</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> callWithMax(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书上一个例子很有意思，假如一个类需要一个成员常量，我们最好将其声明为<code>static</code>类型变量，声明之后还得记得在类外定义它，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostEstimate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> FudgeFactor;			<span class="comment">//static class 常量声明</span></span><br><span class="line">												<span class="comment">//位于头文件内</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> CostEstimate::FudgeFactor = <span class="number">1.35</span>;	<span class="comment">//static class 常量定义</span></span><br><span class="line">												<span class="comment">//位于实现文件内</span></span><br></pre></td></tr></table></figure>

<p>但又有一个很有趣的问题，如果刚在类里声明了一个静态变量（例如<code>static const int num;</code>），紧接着下一行就用这个值指定数组元素个数<code>int arr[num];</code>，此时<code>num</code>还未定义，没有值，所以编译没法通过。于是我们曲线救国，将原本的静态变量换为<code>enum &#123; num = 5; &#125;</code>即可解决问题</p>
<p>对于单纯变量，最好以const对象或enums替换#define</p>
<p>对于形似函数的宏，最好改用inline函数替换#define</p>
<h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><p>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域的对象、函数参数、函数返回类型、成员函数本体</p>
<p>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”<code>conceptual constness</code></p>
<p>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复</p>
<h2 id="条款04：确定对象在使用前已先被初始化"><a href="#条款04：确定对象在使用前已先被初始化" class="headerlink" title="条款04：确定对象在使用前已先被初始化"></a>条款04：确定对象在使用前已先被初始化</h2><p>为内置型对象进行手工初始化，因为C++不保证初始化它们</p>
<p>构造函数最好使用成员初值列<code>member initialization list</code>，而不要在构造函数本题内使用赋值操作<code>assignment</code>。初值列列出的成员变量，其排序次序应该和它们在class中的声明次序相同</p>
<p>为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象</p>
<h1 id="2-构造-析构-赋值运算"><a href="#2-构造-析构-赋值运算" class="headerlink" title="2.构造/析构/赋值运算"></a>2.构造/析构/赋值运算</h1><h2 id="条款05：了解C-默默编写并调用了哪些函数"><a href="#条款05：了解C-默默编写并调用了哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用了哪些函数"></a>条款05：了解C++默默编写并调用了哪些函数</h2><p>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数</p>
<p>你自己实现了其中的某函数后，编译器就不会实现默认版的它了。而且即使你没有实现copy assignment操作符，特定情况下编译器会拒绝替你默认实现，例如成员变量是const，或是reference，又或者这个类的父类将它的copy assignment设为private等情况</p>
<h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Uncopyable() &#123;&#125;								<span class="comment">//允许derived对象构造和析构</span></span><br><span class="line">	~Uncopyable() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);				<span class="comment">//但阻止copying</span></span><br><span class="line">	Uncopyable&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span> <span class="keyword">private</span> Uncopyable &#123;			<span class="comment">//class不再声明</span></span><br><span class="line">	...											<span class="comment">//copy构造函数或</span></span><br><span class="line">&#125;;												<span class="comment">//copy assign. 操作符</span></span><br></pre></td></tr></table></figure>



<h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><p>polymorphic base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数</p>
<p>Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数</p>
<p>给一个类添加一个纯虚函数让它成为一个abstract class，这样它就不能被实例化了，有时这正是我们想要的，但此时我们手上没有任何pure virtual函数，怎么办？那就把析构函数声明成纯虚函数就好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span>	&#123;</span>					<span class="comment">//AWOV = &quot;Abstract w/o Virtuals&quot;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;		<span class="comment">//声明pure virtual析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个class有一个pure virtual函数，所以它是一个抽象class，又由于它有个virtual析构函数，所以你不需要担心析构函数的问题。然而，<strong>你必须为这个pure virtual析构函数提供一份定义：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AWOV::~AWOV() &#123;&#125;				<span class="comment">//pure virtual析构函数的定义</span></span><br></pre></td></tr></table></figure>

<p>析构函数是自外而内的，也就是最深层派生<code>most derived</code>的那个class其析构函数最先被调用，然后像是剥洋葱一样，一层层向上调用其父类的析构函数，最终将会调用这个抽象类的析构函数。因此，如果不给出该抽象类析构函数的定义，连接器会发出抱怨</p>
<h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序</p>
<p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作</p>
<h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h2><p>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）</p>
<h2 id="条款10：令operator-返回要给reference-to-this"><a href="#条款10：令operator-返回要给reference-to-this" class="headerlink" title="条款10：令operator=返回要给reference to *this"></a>条款10：令operator=返回要给reference to *this</h2><p>令赋值操作符返回一个reference to *this</p>
<h2 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator=中处理“自我赋值”"></a>条款11：在operator=中处理“自我赋值”</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span> pb;</span><br><span class="line">	pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原先我认为上述版本的运算符重载函数考虑已足够周全，但书中指出其存在异常安全性问题：先将<code>this-&gt;pb</code>指向的空间释放掉，如果下一行申请空间时出错（例如，空间不足）怎么办呢？</p>
<p>几种方法可以弥补</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Bitmap* pOrig = pb;</span><br><span class="line">	pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">	<span class="keyword">delete</span> pOrig;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;		<span class="comment">//交换*this和rhs的数据；详见条款29</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Widget tmp(rhs);</span><br><span class="line">    swap(tmp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget rhs)</span><br><span class="line">&#123;</span><br><span class="line">	swap(tmp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保当对象自我赋值时operator=有良好行为，其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap</p>
<p>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确</p>
<h2 id="条款12：复制对象时勿忘每一个成分"><a href="#条款12：复制对象时勿忘每一个成分" class="headerlink" title="条款12：复制对象时勿忘每一个成分"></a>条款12：复制对象时勿忘每一个成分</h2><p><strong>Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”</strong></p>
<p>简单说，当新增/删除一个成员变量时，应考虑对构造/析构/拷贝构造/拷贝复制函数进行相应修改</p>
<p>在子类的拷贝构造和拷贝赋值函数中，除了将子类的各成员变量进行拷贝外，还应调用父类的拷贝构造/拷贝赋值。每个类都这么写的话，无论多少层继承都能递归地拷贝下去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">	Data lastTransaction;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span>:</span> <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">	PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PirorityCustomer::PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">	: Customer(rhs), priority(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustmer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">	priority = rhs.priority;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用</p>
<h1 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3.资源管理"></a>3.资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Investment* pInv = createInvestment();</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个函数动态申请了一块内存，在使用后将内存释放。上述代码初看起来很妥当，但若干情况下<code>f()</code>可能无法删除它得自<code>createInvestment()</code>的资源对象——或许是因为“…“区域过早的return语句，或许是在该区域抛出的异常或者别的，甚至即使现在不存在问题， 也许将来代码维护人员在对该函数未能充分理解的情况下做了些改动，导致风险的出现，等等。总之，上面这种做法是有风险的</p>
<p>解决方法是，用对象来管理资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">	...								<span class="comment">//经由auto_ptr的析构函数自动删除pInv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，无论何时退出函数，auto_ptr的析构函数都将忠实地回收资源。以上代码中<code>createInvestment()</code>返回的资源被当做其管理者auto_ptr的初值。实际上“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”<code>Resource Acquisition Is Initialization, RAII</code>。因为我们几乎总是在获得一笔资源后于同一语句内以它初始化某个管理对象，而管理对象运用析构函数确保资源被释放</p>
<p>为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源</p>
<p>两个常被使用的RAII classes分别是<code>tr1::shared_ptr</code>和<code>auto_ptr</code>。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它（被复制物）指向null</p>
<h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为</p>
<p>普遍而常见的RAII class copying行为是：抑制copying、实行引用计数法<code>reference counting</code>。不过其他行为也都可能被实现</p>
<h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><p>APIs往往要求访问原始数据<code>raw resource</code>，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法</p>
<p>对原始资源的访问可能是经由显示转换或隐式转换，一般而言显示转换比较安全，但隐式转换对客户比较方便</p>
<h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用new和delete时要采取相同形式</h2><p>如果你在new表达式中使用了<code>[]</code>，必须在相应的delete表达式中也使用<code>[]</code>。如果你在new表达式中不使用<code>[]</code>，一定不要在相应的delete表达式中使用<code>[]</code></p>
<h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><p>以独立语句将newed对象存储于（置于）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏</p>
<h1 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4.设计与声明"></a>4.设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><p>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质</p>
<p>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</p>
<p>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任</p>
<p><code>tr1::shared_ptr</code>支持定制型删除器<code>custom deleter</code>。这可防范DLL问题，可被用来自动解除互斥锁等等</p>
<h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h2><p>几乎每一个class都要求你面对以下提问，而你的回答往往导致你的设计规范：</p>
<p><strong>新type的对象应该如何被创建和销毁？</strong></p>
<p><strong>对象的初始化和对象的赋值该有什么样的差别？</strong></p>
<p><strong>新type的对象如果被passed by value，意味着什么？</strong>记住，copy构造函数用来定义一个type的pass-by-value该如何实现</p>
<p><strong>什么是新type的“合法值”？</strong></p>
<p><strong>你的新type需要配合某个继承图系<code>inheritance graph</code>吗？</strong></p>
<p><strong>你的新type需要什么样的转换？</strong></p>
<p><strong>什么样的操作符和函数对此新type而言是合理的？</strong></p>
<p><strong>什么样的标准函数应该被驳回？</strong>那些正是你必须声明为private者</p>
<p><strong>谁该取用新type的成员？</strong></p>
<p><strong>什么是新type的“未声明接口”<code>undeclared interface</code>？</strong></p>
<p><strong>你的新type有多么一般化？</strong></p>
<p><strong>你真的需要一个新type吗？</strong></p>
<h2 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h2><p>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题<code>slicing problem</code></p>
<p>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当</p>
<h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象</p>
<h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><p>切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性</p>
<p>protected并不比public更具封装性（当public成员变量发生改变时，多少客户代码需要相应做出改动？当protected成员变量发生改变时，多少derived class代码需要做出改动？）</p>
<h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性<code>packaging flexibility</code>和机能扩充性</p>
<p>书上举的例子是说，如果你的class需要一个便利函数，这个函数的唯一作用就是调用另外几个成员函数，我们既可以将该函数写为一个成员函数，也可以写为普通函数。而写成普通函数更好，因为若把其写成成员函数，它就拥有访问private变量的权力，哪怕它并没有用这权力做什么，而写成普通函数可直接让其丧失该权力，提供封装性。封装并不是一味指把数据和操作数据的函数捆绑在一起，封装的目的是隐藏、降低耦合</p>
<h2 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h2><p>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member</p>
<h2 id="条款25：考虑写出一个不抛异常的swap函数"><a href="#条款25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛异常的swap函数"></a>条款25：考虑写出一个不抛异常的swap函数</h2><p>当<code>std::swap</code>对你的类型效率不高时，提供一个swap成员函数，并确保这个函数不抛出异常</p>
<p>如果你提供一个member swap，也应该提供一个non-member swap用来调用前者，对于classes（而非templates），也请特化<code>std::swap</code></p>
<p>调用swap时应针对<code>std::swap</code>使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”</p>
<p>为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西</p>
<h1 id="5-实现"><a href="#5-实现" class="headerlink" title="5.实现"></a>5.实现</h1><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><p>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率</p>
<h2 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款27：尽量少做转型操作</h2><p>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts，如果有个设计需要转型动作，试着发展无需转型的替代设计</p>
<p>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内</p>
<p>宁可使用C++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌</p>
<h2 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h2><p>避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员变量的行为像个const，并将发生“虚吊号码牌”<code>dangling handles</code>的可能性降至最低</p>
<h2 id="条款29：为”异常安全“而努力是值得的"><a href="#条款29：为”异常安全“而努力是值得的" class="headerlink" title="条款29：为”异常安全“而努力是值得的"></a>条款29：为”异常安全“而努力是值得的</h2><p>异常安全函数<code>Exception-safe functions</code>即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型</p>
<p>“强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义</p>
<p>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者</p>
<h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级<code>binary upgradability</code>更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化</p>
<p>不要只因为<code>function templates</code>出现在头文件，就将它们声明为inline</p>
<h2 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h2><p>支持“编译依存最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes</p>
<p>程序库头文件应该“完全且仅有声明式”<code>full and declaration-only forms</code>的形式存在。这种做法不论是否涉及template都适用</p>
<h1 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6.继承与面向对象设计"></a>6.继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑膜出is-a关系"><a href="#条款32：确定你的public继承塑膜出is-a关系" class="headerlink" title="条款32：确定你的public继承塑膜出is-a关系"></a>条款32：确定你的public继承塑膜出is-a关系</h2><p>“public继承”意味is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象</p>
<h2 id="条款33：避免掩盖继承而来的名称"><a href="#条款33：避免掩盖继承而来的名称" class="headerlink" title="条款33：避免掩盖继承而来的名称"></a>条款33：避免掩盖继承而来的名称</h2><p>derived classes内的名称会掩盖base classes内的名称。在public继承下从来没有人希望如此</p>
<p>为了让被遮掩的名称再见天日，可使用using声明式或转交函数<code>forwarding functions</code></p>
<h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><p> 接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口</p>
<p>pure virtual函数只具体指定接口继承</p>
<p>简朴的（非纯）impure virtual函数具有指定接口继承及缺省实现继承</p>
<p>non-virtual函数具体指定接口继承以及强制性实现继承</p>
<h2 id="条款35：考虑virtual函数以外的选择"><a href="#条款35：考虑virtual函数以外的选择" class="headerlink" title="条款35：考虑virtual函数以外的选择"></a>条款35：考虑virtual函数以外的选择</h2><p>virtual函数的替换方案包括<code>Non-Virtual Interface, NVI</code>手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式</p>
<p>将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员</p>
<p><code>tr1::function</code>对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式<code>target signature</code>兼容”的所有可调用物<code>callable entities</code></p>
<h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf</span><span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base!&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf</span><span class="params">(<span class="keyword">int</span> i = <span class="number">2</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived!&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base* pb1 = <span class="keyword">new</span> Base();</span><br><span class="line">pb1-&gt;mf();					<span class="comment">//Base!1</span></span><br><span class="line"></span><br><span class="line">Base* pb2 = <span class="keyword">new</span> Derived();</span><br><span class="line">pb2-&gt;mf();					<span class="comment">//Derived!1</span></span><br><span class="line"></span><br><span class="line">Derived* pd = <span class="keyword">new</span> Derived();</span><br><span class="line">pd-&gt;mf();					<span class="comment">//Derived!2</span></span><br></pre></td></tr></table></figure>

<p>函数是动态绑定，参数是静态绑定！！！</p>
<h2 id="条款38：通过复合塑模出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或“根据某物实现出”"></a>条款38：通过复合塑模出has-a或“根据某物实现出”</h2><p>复合<code>composition</code>的意义和public继承完全不同</p>
<p>在应用域<code>application domain</code>，复合意味着has-a（有一个）。在实现域<code>implementation domain</code>，复合意味is-implemented-in-terms-of`（根据某物实现出）</p>
<h2 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h2><p>private继承意味is-implemented-in-terms of（根据某物实现出）。它通常比复合<code>composition</code>的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的</p>
<p>和复合不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序开发者而言，可能很重要</p>
<h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><p>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要</p>
<p>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不带任何数据，将是最具有实用价值的情况</p>
<p>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相组合</p>
<h1 id="7-模板和泛型编程"><a href="#7-模板和泛型编程" class="headerlink" title="7.模板和泛型编程"></a>7.模板和泛型编程</h1><h2 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h2><p>classes和templates都支持接口<code>interfaces</code>和多态<code>polymorphism</code></p>
<p>对classes而言接口是显式的<code>explicit</code>，以函数签名为中心。多态则是通过virtual函数发生于运行期</p>
<p>对template参数而言，接口是隐式的<code>implicit</code>，奠基于有效表达式。多态则是通过template具现化和函数重载解析<code>function overloading resolution</code>发生于编译器</p>
<h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p>声明template参数时，前缀关键字class和typename可互换</p>
<p>请使用关键字typename标识嵌套从属类型名称，但不得在base class lists（基类列）或member initialization list（成员函数列）内以它作为base classes修饰符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;		<span class="comment">//base class list中</span></span><br><span class="line"><span class="keyword">public</span>:										<span class="comment">//不允许&quot;typename&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">		: Base&lt;T&gt;::<span class="title">Nested</span><span class="params">(x)</span>				<span class="comment">//mem.init.list中</span></span></span><br><span class="line"><span class="function">		</span>&#123;									<span class="comment">//不允许&quot;typename&quot;</span></span><br><span class="line">			<span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;	<span class="comment">//嵌套从属类型名称</span></span><br><span class="line">			...					<span class="comment">//既不在base class list中也不在mem.init.list中</span></span><br><span class="line">		&#125;						<span class="comment">//作为一个base class修饰符需加上typename</span></span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h2><p>可在derived class templates内通过”this-&gt;”指涉base class templates内的成员名称，或藉由一个明白写出的“base class资格修饰符“完成</p>
<h2 id="条款44：将与参数无关的代码抽离templates"><a href="#条款44：将与参数无关的代码抽离templates" class="headerlink" title="条款44：将与参数无关的代码抽离templates"></a>条款44：将与参数无关的代码抽离templates</h2><p>Template生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系</p>
<p>因非类型模板参数<code>non-type template parameters</code>而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数</p>
<p>因类型参数<code>type parameters</code>而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述<code>binary representations</code>的具现类型<code>instantiation types</code>共享实现码</p>
<h2 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h2><p>请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数</p>
<p>如果你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>(<span class="built_in">shared_ptr</span> <span class="keyword">const</span>&amp; r);				<span class="comment">//copy构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">template</span>&lt;U&gt;</span><br><span class="line">	<span class="built_in">shared_ptr</span>(<span class="built_in">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; r);				<span class="comment">//泛化copy构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">shared_ptr</span> <span class="keyword">const</span>&amp; r);		<span class="comment">//copy assignment</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">template</span>&lt;U&gt;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; r);	<span class="comment">//泛化copy assignment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h2><p>当我们编写一个class template，而它提供之“与此template相关的”函数支持“所有参数之隐式转换”时，请将那些函数定义为“class template内部的friend函数”</p>
<h2 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h2><p>Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现</p>
<p>整合重载技术<code>overloading</code>后，traits classes有可能在编译期对类型执行if…else测试</p>
<h2 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款48：认识template元编程</h2><p>Template metaprogramming（TMP， 模板元编程）可将工作由运行期移往至编译器期，因而得以实现早期错误侦测和更高的执行效率</p>
<p>TMP可被用来生成“基于政策选择组合”<code>based on combinations of policy choices</code>的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码</p>
<h1 id="8-定制new和delete"><a href="#8-定制new和delete" class="headerlink" title="8.定制new和delete"></a>8.定制new和delete</h1><h2 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h2><p>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用</p>
<p>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数还是可能抛出异常</p>
<h2 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h2><p>有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息</p>
<h2 id="条款51：编写new和delete时需固守常规"><a href="#条款51：编写new和delete时需固守常规" class="headerlink" title="条款51：编写new和delete时需固守常规"></a>条款51：编写new和delete时需固守常规</h2><p>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0 bytes申请。Class专属版本还应该处理“比正确大小更大的（错误）申请”</p>
<p>operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的（错误）申请”</p>
<h2 id="条款52：写了placement-new也要写placement-delete"><a href="#条款52：写了placement-new也要写placement-delete" class="headerlink" title="条款52：写了placement new也要写placement delete"></a>条款52：写了placement new也要写placement delete</h2><p>当你写了一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的 内存泄漏</p>
<p>当你声明placement new和placement delete，请确定不要无意识（非故意）地遮掩了它们的正确版本</p>
<p>所谓placement new和placement delete，就是相较于正常的operator new/operator delete有更多参数的版本</p>
<p>常规版operator new如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>而定制版placement new如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="built_in">std</span>::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>写了一个placement new就一定要写一个对应（参数相同）的placement delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="built_in">std</span>::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样使用placement new（假设以上函数均为class Widget的成员函数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> (<span class="built_in">std</span>::<span class="built_in">cerr</span>) Widget();</span><br></pre></td></tr></table></figure>

<p>我们的new多了一个ostream类型的参数，由此知该语句所调用的operator new版本是定制版的。我们知道，new操作符实际分为两个步骤：调用operator new申请内存以及调用构造函数初始化对象。如果第一步申请内存就出了问题（如内存空间不足）则会调用<code>new_handler()</code>函数进行处理；而如果内存申请成功，但调用构造函数出现异常，由于对象并没有真正的构造出来，<code>pw</code>尚未被赋值，客户手上也就没有指针指向该被归还的内存。取消步骤一并恢复旧观的责任因此落到了C++运行期系统身上。运行期系统则会调用与operator new相对应的operator delete来释放内存。所谓相对应，就是指参数个数、参数类型均相同operator delete</p>
<p>注意：就算你的placement operator new没有对应的placement operator delete，编译器也<strong>不会报错</strong></p>
<h1 id="9-杂项讨论"><a href="#9-杂项讨论" class="headerlink" title="9.杂项讨论"></a>9.杂项讨论</h1><h2 id="条款53：不要轻忽编译器的警告"><a href="#条款53：不要轻忽编译器的警告" class="headerlink" title="条款53：不要轻忽编译器的警告"></a>条款53：不要轻忽编译器的警告</h2><p>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉</p>
<p>不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失</p>
<h2 id="条款54：让自己熟悉包括TR1在内的标准程序库"><a href="#条款54：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="条款54：让自己熟悉包括TR1在内的标准程序库"></a>条款54：让自己熟悉包括TR1在内的标准程序库</h2><p>作者零五年写的这书，C++98之后的新标准直到11年才出来，tr1应该就是C++11之前对该标准的称呼</p>
<p>TR1添加了智能指针（例如<code>tr1::shared_ptr</code>）、一般化函数指针<code>tr1::function</code>、hash-based容器、正则表达式以及另外10个组件的支持</p>
<p>TR1自身只是一份规范。为获得TR1提供的好处，你需要一份实物。一个好的实物来源是Boost</p>
<h2 id="条款55：让自己熟悉Boost"><a href="#条款55：让自己熟悉Boost" class="headerlink" title="条款55：让自己熟悉Boost"></a>条款55：让自己熟悉Boost</h2><p>Boost是一个社群，也是一个<a target="_blank" rel="noopener" href="https://boost.org/">网站</a>。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色</p>
<p>Boost提供许多TR1组件实现品，以及其他许多程序库</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/" class="post-title-link" itemprop="url">笔记-计算机网络-自顶向下</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-22 14:03:21" itemprop="dateCreated datePublished" datetime="2021-11-22T14:03:21+08:00">2021-11-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-26 11:04:13" itemprop="dateModified" datetime="2021-12-26T11:04:13+08:00">2021-12-26</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>主机<code>host</code>就是端系统<code>end system</code></p>
<p>端系统通过通信链路<code>communication link</code>和分组交换机<code>packet switch</code>连接到一起</p>
<p>分组交换机包括：路由器<code>router</code>和链路层交换机<code>link-layer switch</code></p>
<p>端系统通过因特网服务提供商<code>Internet Service Provider, ISP</code>接入因特网</p>
<p>多数分组交换机在链路的输入端使用存储转法传输<code>store-and-forward transmission</code>机制。存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到完整的分组</p>
<p>通过网络链路和交换机移动数据有两种基本方法：电路交换<code>circuit switching</code>和分组交换<code>packet switching</code>，在电路交换中，<strong>预留</strong>了端系统间沿路径通信所需的资源（缓存，链路传输速率）。传统的电话网络就是电路交换的例子，在电话拨通前，已在电话网上留出资源，保证了能以恒定速率传输数据。而分组交换并不预留资源，因此当其他分组也需要经过该链路传输时，可能发生拥塞，则该分组不得不在传输链路发送测的缓存中等待而产生时延。</p>
<p>链路上的电路是通过<strong>频分复用</strong><code>Frequency-Division Multiplexing, FDM</code>或<strong>时分复用</strong><code>Time-Division Multiplexing, TDM</code>实现的。电路交换的缺点是不能实现资源的高效利用。比如以时分复用为例，假设将一秒分为1帧，而1帧分为5个时隙，则一个时隙为0.2秒。若建立了一个连接需要通过该链路传数据，该连接分得一个时隙，那么即使该链路上此时就这一个连接在传数据，在1秒内它也只能使用分配给它的0.2秒传数据，剩下0.8秒浪费掉了</p>
<p>一个分组从一个节点传播到后继节点，该分组在每个节点经受了几种不同类型的实现，其中最为重要的是<strong>处理时延</strong><code>processing delay</code>，<strong>排队时延</strong><code>queuing delay</code>，<strong>传输时延</strong><code>transmission delay</code>和<strong>传播时延</strong><code>propagation delay</code>，这几个时延加起来就是<strong>节点的总时延</strong><code>nodal processing delay</code></p>
<p>5层因特网协议（自顶向下）：应用层，运输层，网络层，链路层，物理层</p>
<p>7层ISO OSI参考模型（自顶向下）：应用层，表示层，会话层，运输层，网络层，链路层，物理层</p>
<p>两个协议模型相比较，OSI模型多了两层：表示层（使得通信的应用程序能够解释交换数据的含义）和会话层（提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法）。因特网缺少了OSI参考模型中的两个层次，我们问：这些层次提供的服务不重要吗？如果一个应用程序需要这些服务之一将会怎样呢？因特网对这两个问题的回答相同：这留给应用程序开发者处理。如果一个服务重要，应用程序开发者就应该在应用程序中构建该功能</p>
<p>典型应用层协议如：HTTP（提供Web文档的请求和传送）、SMTP（提供了电子邮件报文的传输）和FTP（提供两个端系统之间的文件传送）；典型的运算层协议如TCP和UDP；典型的网络层协议如IP；链路层的例子如以太网，WiFi和电缆接入网的DOCSIS协议</p>
<p>位于应用层的信息分组称为<strong>报文</strong><code>message</code>，运输层的分组称为<strong>报文段</strong><code>segment</code>，网络层负责将<strong>数据报</strong><code>datagram</code>从一台主机传到另一台主机，我们称链路层分组为<strong>帧</strong><code>frame</code>。对于运输层报文段、网络层数据报和链路层帧而言，一个分组具有两种类型的字段：首部字段和<strong>有效载荷字段</strong><code>payload field</code></p>
<p>链路层交换机实现了物理层和链路层，路由器实现了物理层、链路层和网络层，这意味着路由器能实现IP协议，而链路层交换机不能</p>
<p>拒绝服务攻击<code>Denial-of-Service (DoS) attack</code>短时间内猛烈地向目标发送流量，拥塞网络，使服务陷入瘫痪；分布式DoS<code>Distributed Dos, DDoS</code>从多个源点向目标发送流量</p>
<p>记录每个流经的分组的副本的被动接收机被称为<strong>分组嗅探器</strong><code>packet sniffer</code>；将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗</strong><code>IP spoofing</code></p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>由于套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序与网络之间的<strong>应用程序编程接口</strong><code>Application Programming Interface, API</code></p>
<p>Web的应用层协议是<strong>超文本传输协议</strong><code>HyperText Transfer Protocol, HTTP</code></p>
<p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短几秒内两次请求同一对象，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个<strong>无状态协议</strong><code>stateless protocol</code></p>
<p><strong>往返时间</strong><code>Round-Trip Time, RTT</code>：是指一个短分组从客户到服务器然后再返回客户所花费的时间</p>
<p>典型的HTTP请求报文</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="regexp">/somedir/</span>page.html HTTP<span class="regexp">/1.1		/</span>/请求行 request line</span><br><span class="line"><span class="attr">Host:</span> www.someschool.edu			<span class="comment">//首部行 header line</span></span><br><span class="line"><span class="attr">Connection:</span> close					<span class="comment">//首部行</span></span><br><span class="line">User-<span class="attr">agent:</span> Mozilla<span class="regexp">/5.0				/</span>/首部行</span><br><span class="line">Accept-<span class="attr">language:</span> fr					<span class="comment">//首部行</span></span><br></pre></td></tr></table></figure>

<p>请求行有三个字段：方法字段、URL字段和HTTP版本字段；首部行<code>Host: www.someschool.edu</code>指明了对象所在的主机；<code>Connection: close</code>指明不使用持续连接，让服务器发送完请求的对象后就关闭这条连接；<code>User agent</code>用来指明用户代理，即向服务器发送请求的浏览器类型；最后，<code>Accept-language</code>表示用户希望得到该对象的法语版本</p>
<p>Web缓存器<code>Web cache</code>也叫代理服务器<code>proxy server</code>，是能够代表初始Web服务器来满足自己的磁盘存储的网络实体。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦服务器被配置，每个对某个对象的服务器请求首先被定向到该Web缓存器。举例而言，假设浏览器正在请求对象<code>http://www.someschool.edu/campus.gif</code>，将会发生如下情况：</p>
<p>1）浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求</p>
<p>2）Web缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web缓存器向客户浏览器用HTTP响应报文返回该对象</p>
<p>3）如果没有，它就打开一个与该对象的初始服务器（即<code>www.someschool.com</code>）的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应</p>
<p>4）当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本（通过现有的客户浏览器和Web缓存器之间的TCP连接）</p>
<p>因特网电子邮件系统的三个主要组成部分：<strong>用户代理</strong><code>user agent</code>、<strong>邮件服务器</strong><code>mail server</code>和<strong>简单邮件传输协议</strong><code>Simple Mail Transfer Protocol, SMTP</code>；一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中</p>
<p>SMTP是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。每台邮件服务器上既运行SMTP客户端又运行SMTP服务器端</p>
<p>为描述SMTP的基本操作，我们观察一种常见的情景。假设Alice想给Bob发送一封简单的ASCII报文。</p>
<p>1）Alice调用她的邮件代理程序并提供Bob的邮件地址，撰写报文，然后指示用户代理发送该报文</p>
<p>2）Alice的用户代理把报文发送给她的邮件服务器，在那里该报文被放在报文队列中</p>
<p>3）运行在Alice的邮件服务器上的SMTP客户端发现了报文队列中的这个报文，它就创建一个到运行Bob的邮件服务器上的SMTP服务器的TCP连接</p>
<p>4）在经过一些初始SMTP握手后，SMTP客户通过该TCP连接发送Alice的报文</p>
<p>5）在Bob的邮箱服务器上，SMTP的服务器端接收该报文。Bob的邮件服务器然后将该报文放入Bob的邮箱中</p>
<p>6）在Bob方便的时候，他调用用户代理阅读该报文</p>
<p>思考：Alice想要向Bob发送电子邮件，她首先将邮件推送到自己的邮件服务器，再由邮件服务器将邮件发给Bob的邮件服务器。为什么该过程要分成两步呢？主要是因为如果不通过Alice的邮件服务器进行中继，Alice的用户代理将没有任何办法到达一个不可达的目的地接收服务器。通过首先将邮件存放在自己的邮件服务器中，Alice的邮件服务器可以重复地尝试向Bob的邮件服务器发送该报文。</p>
<p>还有一个值得思考的点：像Bob这样的接收方，是如何通过运行其本地PC上的用户代理获得位于他的某ISP的邮件服务器上的邮件呢？要知道，用户代理不能使用SMTP得到报文，因为取报文是一个拉操作，而SMTP是一个推协议。通过引入一个特殊的邮件访问协议来解决这个难题，该协议将Bob邮件服务器上的报文传送给他的本地PC。目前流行的一些邮件访问协议：<strong>第三版的邮局协议</strong><code>Post Office Protocol Version 3, POP3</code>、<strong>因特网邮件访问协议</strong><code>Internet Mail Access Protocol, IMAP</code>以及HTTP</p>
<p>主机能有许多不同的名字。人类喜欢便于记忆的主机名标识方式，而路由器喜欢定长的、有层次结构的IP地址。为了折中这种偏好，需要一种能进行主机名到IP地址转换的目录服务。这就是<strong>域名系统</strong><code>Domain Name System, DNS</code>的主要任务。DNS是一个由分层的DNS服务器<code>DNS server</code>实现的分布式数据库，也是一个使得主机能够查询分布式数据库的<strong>应用层协议</strong>。DNS协议运行在UDP之上，使用53号端口。</p>
<p>考虑运行在某用户主机上的浏览器请求URL<code>www.someschool.com/index.html</code>页面时会发生什么现象。为了使用户的主机能够将一个HTTP请求报文发送到Web服务器<code>www.someschool.com</code>，该用户主机必须获得<code>www.someschool.com</code>的IP地址。其做法如下。</p>
<p>1）同一台用户主机上运行着DNS应用的客户端</p>
<p>2）浏览器从上述URL中抽出主机名<code>www.someschool.com</code>，并将这台主机名传给DNS应用的客户端</p>
<p>3）DNS客户向DNS服务器发送一个包含主机名的请求</p>
<p>4）DNS客户最终会收到一份回答报文，其中含有对应该主机的IP地址</p>
<p>5）一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器发起一个TCP连接</p>
<p>除了进行主机名到IP地址的转换外，DNS还提供一些重要的服务：<strong>主机别名</strong><code>host aliasing</code>，有复杂主机名的主机能拥有一个或多个（也许）更容易记忆的别名，但只有一个<strong>规范主机名</strong><code>canonical hostname</code>；<strong>邮件服务器别名</strong><code>mail server aliasing</code>，各项功能基本同主机别名；<strong>负载分配</strong><code>load distribution</code></p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong><code>logic communication</code>功能。从应用程序角度看，通过逻辑通信，运行不同进程的主机好想直接相连一样</p>
<p>网络层提供了<em>主机</em>之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信</p>
<p>IP是<strong>不可靠服务</strong><code>unreliable service</code></p>
<p>将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用</strong><code>transport-layer multiplexing</code>与<strong>多路分解</strong><code>demultiplexing</code></p>
<h2 id="构建可靠数据传输协议"><a href="#构建可靠数据传输协议" class="headerlink" title="构建可靠数据传输协议"></a>构建可靠数据传输协议</h2><p><strong>1.经完全可靠信道的可靠数据传输：rdt1.0</strong></p>
<p>假定分组按发送次序进行交付</p>
<p>没有差错！没有丢包！</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt1.0.png" class>

<p><strong>2.经具有比特差错信道的可靠数据传输：rdt2.0</strong></p>
<p>仍然假设按序交付</p>
<p>没有丢包！可能出错</p>
<p>每发送一个分组，发送方等待接收方反馈，若收到NAK，重传分组</p>
<p>每接收一个分组，接收方发送反馈（ACK，NAK）</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.0.png" class>

<p>注意到：当发送方处于等待ACK或NAK状态时，它不能从上层获得更多数据；这就是说，<code>rdt_send()</code>事件不可能出现；仅当接收到ACK并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，<code>rdt2.0</code>这样的协议被称为<strong>停等</strong><code>stop-and-wait</code>协议</p>
<p><strong>3.进一步考虑比特差错的可靠数据传输：rdt2.1</strong></p>
<p><code>rdt2.0</code>只考虑到了对发送方发往接收方的数据进行差错检测，但却忽略了接收方的反馈出错这种情况。假设发送方向接收方发送了一个分组，无论出错与否，接收方都向其发送反馈分组，不幸的是该反馈分组在传输过程中产生比特差错，当发送方接收到该信号后发现该分组是错误的，这时它该怎么办呢？<code>rdt2.0</code>协议无法解决这个问题，于是我们对其稍作改良：当发送方发现反馈分组是错误的时，它不知晓接收方到底有没有正确接收分组，为保险起见，发送方重发刚才的分组。但这里又有个问题：接收方如何区分其接收到的分组是一个新的分组还是重传分组呢？为实现能够对分组进行区分，在数据分组中添加一个新字段，将发送方分组的<strong>序号</strong><code>sequence number</code>放在该字段，于是接收方只需要检查序号即可确定收到的分组是否是一次重传</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.1sender.png" class>

<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.1reciver.png" class>

<p><strong>4.rdt2.1的变种：rdt2.2</strong></p>
<p><code>rdt2.2</code>实现的功能和<code>rdt2.1</code>完全相同，只是实现的方法不同。<code>rdt2.2</code>取消了NAK信号，无论接收方接收到的是预期想要的分组还是一个出错的分组都使用ACK信号进行反馈。如果接收方在期待一个序号值为0的分组，而接收到的分组序号值为1，接收方知道这是一个重传分组，于是向发送方发送一个<code>ACK 1</code>信号，代表接收方已接收到该序列号为1的重传分组。当发送方接收到此<code>ACK 1</code>信号时，自然知道该发送新的、序列值为0的分组</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt2.2.png" class>

<p><strong>5.经具有比特差错的丢包信道的可靠数据传输：rdt3.0</strong></p>
<p>现假定除比特受损外，底层信道还会丢包。协议必须处理两个问题：怎样检查丢包以及发生丢包后该做些什么。发送方发送分组后，等待一段时间，若没能得到应答（可能发送分组丢失，或是反馈分组丢失，亦或是网络拥塞，分组堵在路上了），为保险起见，发送方重传分组，再等待一段时间，如此往复直至收到接收方应答反馈</p>
<p>为实现基于时间的重传机制，需要一个<strong>倒计时计数器</strong><code>countdown timer</code>，在一个给定的时间量过期后，可中断发送方。因此，发送方需要能够做到：1.每次发送一个分组（包括第一次分组和重传分组）时，启动一个定时器；2.响应定时器中断（采取适当的动作）；3.终断定时器。于是便得到<code>rdt3.0</code>协议</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0sender.png" class>

<p><code>rdt3.0</code>的接收方相较于<code>rdt2.2</code>的接收方FSM并没有变化</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0act1.png" class>

<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/rdt3.0act2.png" class>

<p><code>rdt3.0</code>给人感觉不错，已经是一个考虑比较周全的协议，但其实质仍是一个停等协议，效率太低，故考虑<strong>流水线</strong><code>pipelining</code>技术，一次性传多个分组，带来的影响有：1）必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中的未确认报文；2）协议发送方和接收方不得不缓存多个分组；3）如何处理丢失、损坏及延时过大的分组</p>
<p>解决流水线差错恢复两种基本方法是：<strong>回退N步</strong><code>Go-Back-N, GBN</code>和<strong>选择重传</strong><code>Selective Repeat, SR</code></p>
<h2 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h2><img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/GBN.png" class>

<p>图中显示了发送方看到的GBN协议的序号范围，如果我们将<strong>基序号</strong><code>base</code>定义为最早未确认分组的序号，将<strong>下一个序号</strong><code>nextseqnum</code>定义为最小的未使用序号（即下一个待发分组的序号），则可将序号范围分割为4段。在<code>[0, base - 1]</code>段内的序号对应于已经发送并被确认的分组，<code>[base, nextseqnum - 1]</code>段内的序号对应于已经发送并被确认的分组。<code>[nextseqnum, base + N - 1]</code>段内的序号能用于那些要被立即发送的分组（如果有数据来自上层的话），最后，大于或等于<code>base + N</code>的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为<code>base</code>的分组）已得到确认为止</p>
<p>已被发送但还未确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N常被称为<strong>窗口长度</strong><code>window size</code>，GBN协议也常被称为<strong>窗口滑动协议</strong><code>sliding-window protocol</code></p>


<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/GBNreciver.png" class>

<p>注意，在GBN协议中，接收端窗口大小始终为1，当其接收到正确但失序的分组只是将其简单的丢弃</p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SR.png" class>

<p>我个人更喜欢选择重传</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SRdilemma.png" class>

<p>不过需注意，接收端窗口大小需小于等于发送端窗口大小的一半（向下取整），否则会出问题。试想，如果发送端窗口大小为2X，接收端窗口大小为X。发送端先发送序号<code>1 ~ X</code>共X个分组，接收端全接收到，刚好把接收端窗口填满，接收端向后移动X个单位，假设接收端的所有ACK信号全部丢失，待超时时，发送端重发<code>1 ~ X</code>分组，接收端窗口此时期待的序号范围为<code>X + 1 ~ 2X</code>，保证发送端重发的分组的序号不会和接收端窗口期代的新的序号有重叠，避免了上图里情况的发生</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP被称为是<strong>面向连接的</strong><code>connection-oriented</code>，这是因为在一个应用程序可以开始向另一个应用程序发送数据之前，这两个进程必须先“握手”。这种TCP“连接”不是一条像在电路交换网络中的端到端TDM或FDM电路。相反，该“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接</p>
<p>一旦建立起一条TCP连接，两个应用进程之间就可以互相发送数据了。客户进程通过套接字传递数据流，TCP将这些数据引导到该连接的<strong>发送缓存</strong><code>send buffer</code>。TCP可从缓存中取出并放入报文段中的数据数量受限于<strong>最大报文段长度</strong><code>Maximum Segment Size, MSS</code>。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的<strong>最大传输单元</strong><code>Maximum Transmission Unit, MTU</code>）来设置。注意到MSS是指报文段里应用层数据的最大长度，而不是指包含首部的TCP报文段的最大长度</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPformat.png" class>

<p>TCP把数据看成一个无结构的、有序的字节流。<strong>一个报文段的序号</strong><code>sequence number for a segment</code>因此是该报文段首字节的字节流编号。主机A填充进报文段的确认号是主机A希望从主机B收到的下一字节的序号。例如，假设主机A已收到来自主机B的编号为0~535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536</p>
<p>TCP采用<strong>累计确认</strong><code>cumulative acknowledgment</code></p>
<p>TCP为它的应用程序提供了<strong>流量控制服务</strong><code>flow-control service</code>以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。TCP发送方也可能因为IP网络的拥塞而被遏制；这种形式的发送方控制被称为<strong>拥塞控制</strong><code>congestion control</code>。流量控制和拥塞控制采取的动作非常相似，但它们是针对完全不同的原因而采取的措施。流量控制是为了更好的服务两个端系统上的应用程序，而拥塞控制则是着眼整个网络</p>
<p>TCP通过让<em>发送方</em>维护一个称为<strong>接收窗口</strong><code>receive window</code>的变量来提供流量控制。该窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。假设主机A通过一条TCP连接向主机B发送要给大文件，主机B为该连接分配了一个接收缓存，并用<code>RevBuffer</code>表示其大小。我们定义以下变量：</p>
<p><code>LastByteRead</code>：主机B上的应用程序从缓存读出的数据流的最后一个字节的编号</p>
<p><code>LastByteRcvd</code>：从网络中到达的并且已经放入主机B接收缓存中的数据流的最后一个字节的编号</p>
<p>由于TCP不允许已分配的缓存溢出，因此<code>LastByteRcvd - LastByteRead &lt;= RevBuffer</code>成立</p>
<p>接收窗口用<code>rwnd</code>表示，根据缓存可用空间的数量来设置。<code>rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</code>，由于该空间是随着时间变化的，所以<code>rwnd</code>是动态变化的</p>
<p>开始时，主机A设定<code>rwnd = RcvBuffer</code>，主机A轮流跟着两个变量，<code>LastByteSent</code>和<code>LastByteAcked</code>，注意到这两个变量之差就是主机A发送到连接但未被确认的数据量。通过将未确认的数据量控制在值<code>rwnd</code>以内，就可以保证主机A不会使主机B的接收缓存溢出。因此有<code>LastByteSent - LastByteAcked &lt;= rwnd</code></p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP连接建立：<strong>三次握手</strong><code>three-way handshake</code></p>
<p>1）客户端的TCP首先向服务器端的TCP发送一个特殊TCP报文段。该报文段不包含应用层数据，但报文段首部的一个标志位SYN被置1，并且客户会随机选择一个初始化序号<code>client_isn</code></p>
<p>2）一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器从数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户发送允许连接的报文段。该报文段同样不含应用层数据，SYN位置一，确认号字段被置为<code>client_isn + 1</code>，同时将服务器的初始序号<code>server_isn</code>放置到报文段的序号字段中。该允许连接报文段被称为<strong>SYNACK报文段</strong><code>SYNACK segment</code></p>
<p>3）客户端收到SYNACK报文段后，也要为该TCP连接分配缓存和变量，并再向服务器端发送报文来对服务器的允许连接的报文段进行确认（通过将<code>server_isn + 1</code>放置到TCP报文段首部的确认字段来完成此项工作）。因为连接已建立，所以该报文SYN位置零，并且可以在此报文段携带客户到服务器的数据</p>
<p>一旦完成以上三个步骤，客户和服务器主机就可以互相发送包括数据的报文段了。在以后的每一个报文段中，SYN位都置零</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPhandshake.png" class>

<p>第一次握手<code>SYN = 1</code>,客户初始序号，没有数据但消耗一个序号；第二次握手<code>SYN = 1</code>，服务器初始化序号，没有数据，也消耗一个序号；第三次握手<code>SYN = 0</code>，SYN置零，可以包含数据</p>
<p>TCP连接关闭：四次挥手</p>
<p>参与一条TCP连接的<strong>两个进程中的任意一个</strong>都能终止该连接。当连接结束后，主机中的资源（即缓存和变量及端口）都将被释放</p>
<p>1）打算关闭连接的一方A向另一方B发送一个特殊的TCP报文段。该报文段首部的一个标志位FIN被置一</p>
<p>2）当B接收到该FIN报文段后，就向发送方A回送一个ACK确认报文段</p>
<p>3）B也向A发送一个FIN置一的TCP报文段</p>
<p>4）当A收到该报文段后，A同理回送一个ACK确认报文段</p>
<p>至此，双方互相确认完毕断开连接，回收资源</p>
<p>实际中，当第四步A回送确认报文段后并不离开回收资源，而会等一会（可能三十秒或一分钟？具体时间与具体实现相关）,A处于<code>TIME_WAIT</code>状态。假定ACK丢失，<code>TIME_WAIT</code>状态使A重传最后的确认报文。经等待后，连接就正式关闭，释放资源</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPclose.png" class>

<p><strong>SYN洪泛攻击</strong><code>SYN flood attack</code></p>
<p>我们在三次握手中已看到，服务器为了响应一个收到的SYN，分配初始化连接变量和缓存，然后服务器发送一个SYNACK进行响应，并等待来自客户的ACK报文段。如果某客户不发送ACK来完成三次握手的第三步，最终（可能半分钟后）服务器终止并断开该半开连接并回收资源，这为DoS攻击即SYN洪泛攻击提供了环境。随着这种SYN报文纷沓而来，服务器不断为这些半开连接分配资源，导致最终资源消耗殆尽。一种称为<strong>SYN cookie</strong>的技术能有效防御该种攻击</p>
<p>SYN cookie工作原理：当服务器收到一个SYN报文段时并不分配资源。服务器生成一个初始TCP序列号，该序列号是SYN报文段的源和目的IP地址与端口以及仅有该服务器知道的秘密数的一个复杂函数（散列函数）。这种精心制作的初始序列号被称为<code>cookie</code>。服务器则发送具有这种特殊初始序列号的SYNACK分组。<strong>重要的是，服务器并不记忆该<code>cookie</code>或任何对应于SYN的其他状态信息</strong></p>
<p>如果客户是合法的，它将返回一个ACK报文，该报文的确认字段中的数值应该等于用该报文的源和目的IP地址与端口算出来的<code>cookie</code>值再加一。服务器为满足该条件的客户分配资源，建立连接。如此这般，无论客户不返回ACK报文或是返回一个伪造的报文，都不会消耗服务器资源</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>TCP采用端到端拥塞控制而不是网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。如果一个TCP发送方感知沿该路径有拥塞，则发送方会降低其连接发送流量的速率。但这种方法提出了三个问题：1）一个TCP发送方如何限制它向其他连接发送流量的数据呢？2）一个TCP发送方如何感知从它到目的地之间的路径存在拥塞呢？3）采用何种算法来改变其发送速率呢？</p>
<h4 id="1）如何限制一个TCP发送方发送流量的速率"><a href="#1）如何限制一个TCP发送方发送流量的速率" class="headerlink" title="1）如何限制一个TCP发送方发送流量的速率"></a>1）如何限制一个TCP发送方发送流量的速率</h4><p>运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即<strong>拥塞窗口</strong><code>congestion window</code>。拥塞窗口表示为<code>cwnd</code>，它对一个TCP发送方能向网络中发送流量的速率进行了限制。已发送但没被确认的数据量满足以下限制：</p>
<p><code>LastByteSent - LastByteAcked &lt;= min&#123; cwnd, rwnd &#125;</code></p>
<p>为关注拥塞控制（与流量控制形成对比），假设<code>rwnd</code>足够大，以至于可以忽略接收窗口的限制；因此在发送方中未被确认的数据量受限于<code>cwnd</code>。通过调整<code>cwnd</code>大小即可动态控制发送速率</p>
<h4 id="2）如何感知拥塞"><a href="#2）如何感知拥塞" class="headerlink" title="2）如何感知拥塞"></a>2）如何感知拥塞</h4><p>简单！丢包事件发生（超时或3次冗余ACK）即意味着网络拥塞，发送方应减小拥塞窗口大小，降低传输速率；另一方面，若发送方收到对于以前未确认的报文段的确认，则将其理解为一切正常的指示，增大拥塞窗口大小，增加发送速率。而且，如果确认以低速率到达，则拥塞窗口应以低速率增大；确认以高速率达到则拥塞窗口以高速率增大</p>
<h4 id="3）何种算法来改变发送速率"><a href="#3）何种算法来改变发送速率" class="headerlink" title="3）何种算法来改变发送速率"></a>3）何种算法来改变发送速率</h4><p>通过广受赞誉的<strong>TCP拥塞控制算法</strong><code>TCP congestion control algorithm</code>实现。该算法包括三个主要部分：慢启动、拥塞避免和快速恢复（快速恢复是推荐部分，而不是必需的）</p>
<h5 id="1-慢启动slow-start"><a href="#1-慢启动slow-start" class="headerlink" title="1.慢启动slow start"></a>1.慢启动<code>slow start</code></h5><p>当一条TCP连接开始时，<code>cwnd</code>的值通常初始置为一个MSS的较小值，每当传输报文段首次被确认就就增加一个MSS。这样，1至2，2至4，4至8…每过一个RTT，发送速率就翻番，直至丢包事件发生（超时或三次冗余ACK）</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPslowstart.png" class>

<p>若超时，将状态变量<code>ssthresh</code>（”慢启动阈值“的速记）的值设为此时<code>cwnd</code>大小的一半，重设<code>cwnd</code>值为1并重新进行慢启动。当<code>cwnd</code>窗口大小又逐渐增大至<code>ssthresh</code>，继续使<code>cwnd</code>翻番可能有些鲁莽，于是进入拥塞避免阶段</p>
<h5 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2.拥塞避免"></a>2.拥塞避免</h5><p>在拥塞避免阶段，TCP无法每个RTT再将<code>cwnd</code>值翻番，而是采取保守方法，每次RTT只将其增大一个MSS大小</p>
<h5 id="3-快速恢复"><a href="#3-快速恢复" class="headerlink" title="3.快速恢复"></a>3.快速恢复</h5><p>懒得打字了</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPcongestioncontrol.png" class>

<h3 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h3><p>考虑K条TCP链接，每条都有不同的端到端路径，但都经过一段传输速率为R bps的瓶颈链路。假设每条连接都在传输一个大文件，而且无UDP流量通过该段瓶颈链路。如果每条连接的平均传输速率接近<code>R/K</code>，即每条连接都得到相同份额的链路带宽，则认为该拥塞控制机制是公平的。而TCP的AIMD拥塞控制算法是<strong>公平的</strong></p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/TCPfair.png" class>

<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p><strong>转发</strong><code>forwarding</code>是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。转发发生的时间尺度很短（通常为几纳秒），因此通常用硬件来实现</p>
<p><strong>路由选择</strong><code>routing</code>是指确定分组从源到目的地所采用的端到端路径的网络范围处理过程。时间尺度长的多（通常几秒），因此通常软件实现</p>
<p>考虑一个驾驶员从宾夕法尼亚州到佛罗里达州的行程。在行程中该驾驶员经过了许多立交桥。我们能够认为<strong>转发</strong>就像通过<strong>单个立交桥</strong>的过程：一辆汽车从其道路上进入立交桥的一个入口，并且决定应当走哪条路来离开该立交桥。我们可以把<strong>路由选择</strong>看作是<strong>规划从宾夕法尼亚州到佛罗里达州行程</strong>的过程：在着手行程前，驾驶员已经查阅了地图并在许多可能的路径中选择一条，其中每条路径都由一系列经立交桥连接的路段组成</p>
<p>网络层的数据平面执行主要功能就是转发，而网络层的控制平面执行的主要功能是路由选择</p>
<p>每台网络路由器中有一个关键元素是它的转发表<code>forwarding table</code>。路由器检查到达分组首部的一个或多个字段，进而使用这些首部值在其转发表中索引来转发分组</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/forward_table.png" class>

<p>于是我们不禁思考：路由器中的转发表一开始是如何配置的呢？</p>
<p>传统的方法是，在每条路由器中运行路由选择算法，由路由选择算法决定插入该路由器转发表中的内容，故每台路由器都包含转发和路由选择两种功能。一台路由器中的路由选择算法与在其他路由器中的路由选择算法通信，以计算出它的转发表值。这种通信又是如何执行呢？通过根据路由选择协议交换包含路由选择信息的路由选择报文！</p>
<p>而另一种方法，<strong>软件定义网络</strong><code>Software-Defined Networking, SDN</code>，将路由选择从路由器中分离：远程控制器计算和分发转发表以供每台路由器使用，而<strong>路由设备仅执行转发</strong>。远程控制器可能实现在具有高可靠性和冗余的远程数据中心中，并可能由ISP或某些第三方管理。路由器和远程控制器是如何通信呢？通过交换包含转发表和其他路由选择信息的报文</p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p>下图显示了一个通用路由器体系结构的总体视图</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/RouterArchitectureOutview.png" class>

<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p>图左边的<strong>输入端口</strong><code>input port</code>表现为一个大的矩形，每个端口矩形内部还有三个方框，其中左起第一个绿色方框负责执行终结入物理链路的物理层功能（线路端接），中间棕色方块代表端口负责与位于入链路远端的数据链路层交互来执行数据链路层功能（数据链路处理（协议，拆封）），右边的红色方块代表端口要执行的查找功能（查找，转发，排队）</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>存在三种交换结构用于总体视图中交换结构的实现：经内存交换，经总线交换和经互联网交换</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/SwitchingFabrics.png" class>

<h4 id="经内存交换"><a href="#经内存交换" class="headerlink" title="经内存交换"></a>经内存交换</h4><p>通过将输入端口传入的分组数据复制于内存，由路由选择处理器于其首部提取目的地址，在转发表中找出适当的输出端口，并将该分组复制到输出端口的缓存中。假设内存带宽为每秒可读写进内存或从内存读出最多B个分组，则总转发吞吐量必然小于B/2。也要注意到不能同时转发两个分组，即使它们有不同的目的端口，因为经过共享系统总线一次仅能执行一个内存读写</p>
<h4 id="经总线交换"><a href="#经总线交换" class="headerlink" title="经总线交换"></a>经总线交换</h4><p>输入端口经一根共享总线将分组直接传输到输出端口，不需要路由选择处理器的干预。通过让输入端口为分组预先计划一个交换机内部标签（首部），指示本地输出端口，使分组在总线上传送和传输到输出端口。该分组能由所有输出端口收到，但只有与该标签匹配的端口才能保存该分组，然后标签在输出端口被去除。采用该方法，除了一个分组外所有其他分组必须等待，因为一次只有一个分组能够跨越总线</p>
<h4 id="经互联网络交换"><a href="#经互联网络交换" class="headerlink" title="经互联网络交换"></a>经互联网络交换</h4><p>如上述PPT中右侧图片所示，纵横式交换机是<strong>非阻塞的</strong><code>non-blocking</code>，即只要没有其他分组当前被转发到该输出端口，转发到输出端口的分组将不好被到达输出端口的分组阻塞。当然，如果两个不同的输入端口同时打算转发至相同输出端口，则其中一个需要等待</p>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p>输出端口做的事情有点像是输入端口的逆过程，从左到右三个子方框分别代表：1）排队（缓存管理），2）数据链路处理（协议，封装），3）线路端接</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><h4 id="输入排队"><a href="#输入排队" class="headerlink" title="输入排队"></a>输入排队</h4><p>何时会出现输入排队呢？试想，一台路由器有N个输入端口，假设每个时间单位内每个输入端口均收到一个分组，若在该时间单位内交换结构不能将N个分组全部转发，那么必然部分输入端口在该时间单位内没能来得及将分组转发，而一个时间单位后又有新的分组到达。如果这种情形一致持续，每个时间单位内都有部分输入端口得不到转发，总体来看，平均每个输入端口的队列将越来越长，直至最终缓存溢出，丢包事件发生</p>
<h4 id="输出排队"><a href="#输出排队" class="headerlink" title="输出排队"></a>输出排队</h4><p>何时会出现输出排队呢？假设交换结构是纵横式的，一个时间单位内N个输入端口均收到分组，且这些分组全都需要转发至同一输出端口，而交换结构工作得够快，能够在一个时间单位内将N个分组全部转发至目标端口。而不幸的是该输出端口没有能力在一个时间单位内将N个分组全部传输，如果在一段时间内持续不断的许多分组转发至同一输出端口，当输出端口没有足够的内存来缓存一个入分组时，就必须做出决定：要么丢弃到达的分组（采用一种称为<strong>弃尾</strong><code>drop-tail</code>的策略），要么删除一个或多个已排队的分组来为新来的分组腾出空间。在某些情况下，在缓存填满之前便丢弃一个分组，以向发送方提供一个拥塞信号是有利的。这种策略统称为<strong>主动队列管理</strong><code>Active Queue Management, AQM</code>，<strong>随机早期检测</strong><code>Random Early Detection, RED</code>算法是得到最广泛研究和实现的AQM算法之一</p>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/IPformat.png" class>

<p> 一个链路层帧能承载的最大数据量叫作被叫作<strong>最大传送单元</strong><code>Maximum Transmission Unit, MTU</code>。如果IP数据报过大，将其分片为多个较小的IP数据报，用单独的链路层帧封装这些较小的IP数据报，然后通过输出链路发送这些帧。每个这些较小的数据报都称为<strong>片</strong><code>fragment</code></p>
<p>分片后，并不是从该路由器发往下一个路由器又重新组装，而是待所有的片到达端系统后再组装</p>
<p>一台主机通常只有一条链路连接到网络，当一台主机中的IP想要发送一个数据报时，它就在该链路上发送。主机和物理链路之间的边界叫作<strong>接口</strong><code>interface</code>。现在考虑一台路由器及其接口。因为路由器的任务是从链路上接收数据报并从某些其他链路转发出去，路由器必须拥有两条或者更多链路与它连接。路由器与它的任意一条链路之间的边界也叫作接口。一台路由器因此有多个接口，每个接口有其链路。因为每台主机与路由器都能发送和接收IP数据报，IP要求每台主机和路由器接口拥有自己的IP地址。<strong>因此，从技术上讲，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联</strong></p>
<p>因特网的地址分配策略被称为<strong>无类别域间路由选择</strong><code>Classless Interdomain Routing, CIDR</code>。形式为<code>a.b.c.d/x</code>的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的<strong>前缀</strong><code>prefix</code>（或网络前缀）。一个地址的剩余<code>32 - x</code>比特可认为是用于区分该组织内部设备的，其中的所有设备具有相同的网络前缀。当该组织内部的路由器转发分组时，才会考虑这些比特。也就是说，当该组织外部的一台路由器转发一个数据报，且该数据报的目的地址位于该组织内部时，仅需要考虑该地址的前x比特。这相当大程度地减少了在这些路由器中转发表的长度</p>
<p>几个接口通过一个并不包含路由器的网络互连起来，形成一个<strong>子网</strong><code>subnet</code>。例如IP编制为某子网分配一个地址<code>223.1.1.0/24</code>，其中<code>/24</code>计法有时称为<strong>子网掩码</strong><code>network mask</code>，指示32比特中最左侧的24比特定义了子网地址</p>
<p>IP广播地址为<code>255.255.255.255</code>。当一台主机发送一个目的地址为<code>255.255.255.255</code>的数据报时，该报文会交付给同一个网络中的所有主机。路由器也会有选择地向领近的子网转发该报文（虽然它们通常不这样做）</p>
<h3 id="获取主机地址：动态主机配置协议"><a href="#获取主机地址：动态主机配置协议" class="headerlink" title="获取主机地址：动态主机配置协议"></a>获取主机地址：动态主机配置协议</h3><p>某组织一旦获得了一块地址，它就可为本组织内的主机与路由器接口逐个分配IP地址。主机地址也能手动配置，但这项任务目前更多的是使用<strong>动态主机配置协议</strong><code>Dynamic Host Configuration, DHCP</code>来完成。DHCP允许主机自动获取一个IP地址，或分配某主机一个<strong>临时IP地址</strong><code>temporary IP address</code>。除了分配主机IP地址外，DHCP还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器网址（常称为默认网关）与它的本地DNS服务器的地址</p>
<p>由于DHCP具有将主机连接进一个网络的网络相关方面的自动能力，故它又常被称为<strong>即插即用协议</strong><code>plug-and-play protocol</code>或<strong>零配置协议</strong><code>zeroconf</code></p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DHCP.png" class>

<p>DHCP四个步骤的过程：</p>
<p>1）DHCP服务器发现。一台新到达的主机的首要任务是发现一个要与其交互的DHCP服务器。这可通过使用<strong>DHCP发现报文</strong><code>DHCP discover message</code>来完成，客户在UDP分组向端口67发送该发送报文，使用广播目的地址<code>255.255.255.255</code>并使用“本主机”源IP地址<code>0.0.0.0</code>。DHCP客户将该IP地址传递给链路层，链路层然后将该帧广播到所有与该子网连接的节点</p>
<p>2）DHCP服务器提供。DHCP服务器收到一个DHCP发现报文时，用<strong>DHCP提供报文</strong><code>DHCP offer message</code>向客户做出响应，该报文向该子网的所有节点广播，仍然使用IP广播地址<code>255.255.255.255</code>。因为子网中可能存在几个DHCP服务器，该用户可从几个提供者间进行选择。每台服务器提供的报文包含有收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及<strong>IP地址租用期</strong><code>address lease time</code></p>
<p>3）DHCP请求。新到达的客户从一个或多个服务器中选择一个，并向选中的服务器提供用<strong>DHCP请求报文</strong><code>DHCP request message</code>进行响应，回显配置的的参数</p>
<p>4）DHPC ACK。服务器用<strong>DHCP ACK报文</strong><code>DHCP ACK message</code>对DHCP请求报文进行响应，证实所要求的参数</p>
<p>一旦客户收到DHCP ACK后，交互便完成了</p>
<h3 id="网络地址转换-Network-Address-Translation-NAT"><a href="#网络地址转换-Network-Address-Translation-NAT" class="headerlink" title="网络地址转换 Network Address Translation, NAT"></a>网络地址转换 Network Address Translation, NAT</h3><p>地址空间<code>10.0.0.0/8</code>是在[RFC 1918]中保留的三部分IP地址空间之一，这些地址用于家庭网络等<strong>专用网络</strong><code>private network</code>或<strong>具有专用地址的地域</strong><code>realm with private address</code>。具有专用地址的地域是指其地址仅对该网络中的设备有意义的网络。考虑有数十万家庭网络这样的事实，许多使用了相同地址空间<code>10.0.0.0/24</code>。在一个给定家庭网络中的设备能够使用<code>10.0.0.0/24</code>编址彼此发送分组。然而，转发到家庭网络之外进入更大的全球互联网的分组显然不能使用这些地址（或作为源地址，或作为目标地址），因为有数十万的网络使用着这块地址。这就是说，<code>10.0.0.0/24</code>地址仅在给定的网络中才有意义。但如果专用地址仅在给定的网络中才有意义的话，当向或从全球因特网发送或接收分组时如何处理编址问题呢，地址在何处才必须是唯一的呢？答案在于理解NAT</p>
<p>NAT使能路由器对于外界世界来说甚至不像一台路由器。相反NAT路由器对外界的行为就如同一个具有单一IP地址的单一设备。从本质上讲，NAT使能路由器对外界隐藏了家庭网络的细节。家庭网络计算机从何处得到其地址，路由器又是从何处得到它的单一IP地址呢？通常情况下，答案是相同的，即DHCP！路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间中的计算机提供地址</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/NAT.png" class>

<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>一个经常问的问题是：IPv5出了什么情况？人们最初预想ST-2协议将成为IPv5，但ST-2后来被舍弃了</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/IPv6format.png" class>

<p>在实践中已经得到广泛采用的IPv4到IPv6迁移的方法包括<strong>建隧道</strong><code>tunneling</code>。我们将两台IPv6路由器之间的中间IPv4路由器集合称为一个<strong>隧道</strong><code>tunnel</code>。借助于隧道，在隧道发送端的IPv6节点可将整个IPv6数据报放到一个IPv4数据报的数据（有效载荷）字段中。于是，该IPv4数据报的地址设为指向隧道接收端的IPv6节点，再发送给隧道中的第一个节点。隧道中间的IPv4路由器在它们之间为该数据报提供路由，就像对待其他数据报一样，完全不知道该IPv4数据报自身就含有一个完整的IPv6数据报。隧道接收端的IPv6节点最终收到该IPv4数据报，从中取出IPv6数据报，然后再为该IPv6数据报提供路由，就好像它是从一个直接相连的IPv6邻居那里接收到该IPv6数据报的一样</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/tunneling.png" class>

<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p><strong>路由选择算法</strong><code>routing algorithm</code>的一种分类方式是根据该算法是集中式还是分散式来划分</p>
<p><strong>集中路由选择算法</strong><code>centralized routing algorithm</code>用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有开销为输入，这就要求算法在真正开始计算前要以某种方式获得这些信息。具有全局状态信息的算法常被称作<strong>链路状态算法</strong><code>Link State, LS</code></p>
<p>在<strong>分散式路由选择算法</strong><code>decentralized routing algorithm</code>中，路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。相反，每个节点仅有与其直接相连链路的开销知识即可开始工作，然后通过迭代计算过程以及与相邻节点的信息交换逐渐计算出到达目的节点或一组目的节点的最低开销路径。<strong>距离向量算法</strong><code>Distance-Vector, DV</code>是分散式路由选择算法的一个例子</p>
<p>第二种广义分类方式是根据算法是静态的还是动态的进行分类。在<strong>静态路由选择算法</strong>·<code>static routing algorithm</code>中，路由随时间的变化非常缓慢，通常是人工进行调整。<strong>动态路由选择算法</strong><code>dynamic routing algorithm</code>随着网络流量负载或拓扑发生变化而改变路由选择路径</p>
<p>第三种分类方式是根据它是负载敏感的还是负载迟钝的进行划分。在<strong>负载敏感算法</strong><code>load-sensitive algorithm</code>中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。当今因特网路由选择算法（如RIP、OSPF和BGP）都是<strong>负载迟钝的</strong><code>load-insensitive</code>，因为某条链路的开销不明确地反映其当前（或最近）的拥塞水平</p>
<h2 id="链路状态算法"><a href="#链路状态算法" class="headerlink" title="链路状态算法"></a>链路状态算法</h2><p>链路状态算法的一个具体例子就是<code>Dijkstra</code>算法，通过运行该算法，每台路由器都将知道从自己出发到任意目的点的最优解，但若该算法是拥塞敏感的，网络中的路由选择可能会<strong>振荡</strong><code>Oscillation</code></p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/Oscillation.png" class>

<p>防止该振荡的一种解决方式是强制链路开销不依赖于所承载的流量，但这是一种不可接受的方案，因为路由选择的目标之一就是要避开高度拥塞的链路。另一种方案是确保并非所有的路由器都同时运行LS算法，因为我们希望即使路由器以相同周期运行LS算法，在每个节点上执行的时机也是不同的。有趣的是，研究发现因特网上的路由器能在它们之间进行自同步。这就是说，即使它们初始以同一周期但在不同时刻执行算法，算法执行时机最终会在路由器上变为同步并保持之。避免这种自同步的一种方法是，让每台路由器发送链路通告的时间随机化</p>
<h2 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h2><p>距离向量算法则是基于<code>Bellman-Ford</code>方程</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA1.png" class>

<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA2.png" class>

<p>该算法存在缺陷：当两路由器间链路开销发生变化（例如，开销增大）时，可能在网络中形成<strong>路由选择环路</strong><code>routing loop</code>，如下图所示</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/DVA3.png" class>

<p>原本y到x开销为4，z经y到x开销为5.当(x, y)间链路开销突增至60时，我们期待的正确结果是：z通过开销为50的链路直接到达x，而y也通过z到达x，总开销为51.但实际上，y查询它的转发表，发现z到x开销为5（其实z正是通过y到达x的，但y不知道），于是y将其到x的路径改为先从y到z，再从z到x,总开销为6。设想有一个分组传至y路由器，其目的地址为x，则y将该分组发向z，z又传回给y…如此循环往复</p>
<p>一种称为<strong>毒性逆转</strong><code>poisoned reverse</code>的算法可以避免两个路由间可能的路由选择环路，其思想是，如果z是通过y到达x的，则z告诉y它到x的距离为无穷大，即使实际上并不是。如此一来，还是上图中的情形，当(x, y)间开销增至60时，y发现它直接到x开销为60，而若选择走z这条路开销则是无穷，它别无选择，只能是直接到达x。当y修改其转发表后将新的数据发往z，z此时发现通过y再到x还不如直达x划算，于是修改路由为直接到达x，z又将新的数据发往y，接着y发现通过z到x开销更小，于是转而选择通过z到x。这样，一切和我们期待的一致</p>
<p>但毒性逆转无法解决多个路由形成的环路</p>
<p>总之，LS算法与DV算法没有一个是明显的赢家，它们的确都在因特网中得到了应用</p>
<h2 id="因特网自治系统内部的路由选择：OSPF"><a href="#因特网自治系统内部的路由选择：OSPF" class="headerlink" title="因特网自治系统内部的路由选择：OSPF"></a>因特网自治系统内部的路由选择：OSPF</h2><p>之前的学习中，我们将网络只看作一个互联路由器的集合。从所有路由器执行相同的路由选择算法计算穿越整个网络的路由选择路径的意义上来说，一台路由器很难同另一台路由器区分开来，在实践中，该模型和这种一组执行同样路由选择算法的同质路由器集合的观点有点简单化，有两个重要原因：</p>
<p>1）规模。随着路由器数目规模变得很大，涉及路由选择信息的通信、计算和存储开销将高得不可实现</p>
<p>2）管理自治。因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器（如在自己的网络中运行它所选择的某种路由选择算法），或对外部隐藏其网络的内部组织面貌。理想情况下，一个组织应当按照自己的愿望运行和管理其网络，还要能将其网络与其他外部网络连接起来</p>
<p>这两个问题都可以通过路由器组织进<strong>自治系统</strong><code>Autonomous System, AS</code>来解决。在相同AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行的路由选择算法叫作<strong>自治内部路由选择协议</strong><code>intra-autonomous system routing protocol</code></p>
<p><strong>开放最短路优先</strong><code>OSPF</code>路由选择及其关系密切的协议IS-IS都广泛用于因特网的AS内部路由选择。ISPF中的开放<code>open</code>指路由选择协议规范是公众可用的，该协议使用洪泛链路状态信息和<code>Dijkstra</code>最低开销路径算法。使用OSPF，一台路由器构建了一幅关于整个自治系统的完整拓扑图，而各条链路开销是由网络管理员配置的。OSPF的优点包括：1）安全，2）多条相同开销的路径。当到达某目的地的多条路径具有相同的开销时，OSPF允许使用多条路径，3）对 单播和多播路由选择的综合支持，4）支持在单个AS中的层次结构</p>
<h2 id="ISP之间的路由选择：BGP"><a href="#ISP之间的路由选择：BGP" class="headerlink" title="ISP之间的路由选择：BGP"></a>ISP之间的路由选择：BGP</h2><p>OSPF是一个AS内部路由选择协议，而不同AS之间需要通过<strong>自治系统间路由选择协议</strong><code>inter-autonomous system routing protocol</code>进行协调。在因特网中，所有的AS运行相同的AS间路由选择协议，称为<strong>边界网关协议</strong><code>Broder Gateway Protocol, BGP</code>，BGP十分重要，正是这个协议将因特网中数以千计的ISP黏合起来。BGP是一种分布式和异步协议</p>
<p>当路由器通过BGP连接通告前缀时，它在前缀中包含一些<strong>BGP属性</strong> <code>BGP attribute</code>。用BGP术语来说，前缀及其属性称为<strong>路由</strong><code>route</code>。两个较为重要的属性是AS-PATH和NEXT-HOP。AS-PATH属性包含了通告已经通过的AS的列表，该AS将其ASN加入AS-PATH中现有列表。BGP路由器还使用AS-PATH属性来检测和防止通告环路；特别是，如果一台路由器在路径列表中看到包含了它自己的AS，它将拒绝该通告；NEXT-HOP是AS-PATH起始路由接口的IP地址。对于从AS1通过AS2到x的路由“AS2 AS3 x“，其属性NEXT-HOP是路由2a左边接口的IP地址。注意到NEXT-HOP属性<strong>不属于</strong>AS1的某路由器的IP地址；然而，包含该IP地址的子网直接连接到AS1</p>
<p>作为一种AS间的路由选择协议，BGP为每台路由器提供了一种完成以下任务的手段：1）从邻居AS获得前缀的可达性信息。特别是，BGP允许每个子网向因特网的其余部分通知它的存在；2）确定到该前缀的“最好的”路由</p>
<p>对于每个AS，每台路由器要么是一台<strong>网关路由器</strong><code>gateway router</code>，要么是一台<strong>内部路由器</strong><code>internel router</code></p>
<p><strong>热土豆路由选择</strong><code>hot potato routing</code>是一种较为简单的BGP路由选择算法。若一台路由器到达前缀x有两条BGP路由，使用热土豆路由选择，（从所有可能的路由中）选择的路由到开始该路由的NEXT-HOP路由器具有最小开销。假设开销定义为穿越的链路数，则该路由选择离它跳数最少的NEXT-HOP</p>
<p>在实践中，BGP使用了一种比热土豆路由选择算法更加复杂但却结合了其特点的算法，如果到相同的前缀有两条或多条路由，则顺序地调用下列消除规则直到余下一条路由：</p>
<p>1）路由被指派一个<strong>本地偏好</strong><code>local preference</code>值作为其属性之一（除了AS-PATH和NEXT-HOP以外）。本地偏好属性的值是一种策略决定，它完全取决于该AS的网络管理员。具有最高本地偏好值的路由将会被选择</p>
<p>2）从余下的路由中（所有都具有相同的最高本地偏好值），将选择具有最短AS-PATH的路由。如果该规则是路由选择的唯一规则，则BGP将使用距离向量算法决定路径，<strong>其中距离测度使用AS跳数而不是路由器跳数</strong></p>
<p>3）从余下的路由中（所有都具有相同的最高本地偏好值和相同的AS-PATH长度），使用热土豆选择，即选择具有最靠近NEXT-HOP路由器的路由</p>
<p>4）如果仍留下多条路由，该路由器使用BGP标识符来选择路由</p>
<p>教材用的英文第五版，我用的中文第七版，第七版后面还有一点内容，但我实在懒得打字了</p>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>为了透彻理解链路层以及它是如何与网络层关联的，我们考虑一个交通运输的类比例子。假设一个旅行计划为游客开辟从美国新泽西州的普林斯顿到瑞士洛桑的旅游路线。假定该旅行社认为对于游客而言最为便利的方案是：从普林斯顿乘豪华大轿车到JFK机场，然后乘飞机从JFK机场去日内瓦机场，最后乘火车从日内瓦机场到洛桑火车站。一旦该旅行社作了这3项预定，普林斯顿豪华大轿车公司将负责将游客从普林斯顿带到JFK，航空公司将负责将游客从JFK带到日内瓦，瑞士火车服务将负责将游客从日内瓦带到洛桑。该旅途中3段中的每一段都在两个“相邻”地点之间是“直达的”。注意到这3段运输是由不同的公司管理，使用了完全不同的运输方式（豪华大轿车、飞机和火车）。尽管运输方式不同，但它们都提供了将旅客从一个地点运输到相邻地点的基本服务。在这个运输类比中，一个游客好比一个数据报，每个运输区段好比一条链路，每种运输方式好比一种链路层协议，而该旅行社好比一个路由选择协议</p>
<p>链路层能够提供的<strong>可能</strong>服务包括：<strong>成帧</strong><code>framing</code>；链路接入。<strong>媒体访问控制</strong><code>Medium Access Control, MAC</code>协议规定了帧在链路上传输的规则；可靠交付；差错检测和纠正</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/networkPhysical.png" class>

<p>链路层的主体部分是在<strong>网络适配器</strong><code>network adapter</code>中实现的，网络适配器有时也称为<strong>网络接口卡</strong><code>Network Interface Card, NIC</code>。位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测等）的专用芯片</p>
<p>差错检测和纠正技术有：1）奇偶校验，包括使用单个<strong>奇偶检验位</strong><code>parity bit</code>和<strong>二维奇偶校验</strong><code>two-dimensional parity</code>；2）检验和方法；3）<strong>循环冗余检测</strong><code>Cyclic Redundancy Check, CRC</code><strong>编码</strong></p>
<p>如何协调多个发送和接收节点对一个共享广播信道的访问，这就是<strong>多路访问问题</strong><code>multiple access problem</code>，解决这个问题的协议即所谓<strong>多路访问协议</strong><code>multiple access protocol</code></p>
<p>因为所有节点都能传输帧，所以多个节点可能会同时传输帧。当发生这种情况时，所有节点同时接收到多个帧；这就是说，传输的帧在所有的接收方处<strong>碰撞</strong><code>collide</code>了。涉及此次碰撞的所有帧都丢失了，在碰撞时间间隔中的广播信道被浪费了</p>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>多年来以实现几十种多路访问协议，其中任意一种都可划分为3种类型之一：<strong>信道划分协议</strong><code>channel partitioning protocol</code>，<strong>随机接入协议</strong><code>random access protocol</code>和<strong>轮流协议</strong><code>taking-turns protocol</code></p>
<p>在理想情况下，对于速率为R bps的广播信道，多路访问协议应该具有以下所希望的特性：</p>
<p>1）当且仅当一个节点发送数据时，该节点具有R bps的吞吐量；</p>
<p>2）当有M个节点发送数据时，每个节点吞吐量为R/M bps。这不必要求M个节点中的每一个节点总是有R/M的瞬时速率，而是每个节点在一些适当定义的时间间隔内应该有R/M的平均传输速率</p>
<p>3）协议是分散的，这就是说不会因为某主节点故障而使整个系统崩溃</p>
<p>4）协议是简单的，使实现不昂贵</p>
<h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>时分多路复用<code>TDM</code></p>
<p>频分多路复用<code>FDM</code></p>
<p><strong>码分多址</strong><code>Code Division Multiple Access, CDMA</code></p>
<h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>时隙ALOHA</p>
<p>ALOHA</p>
<h4 id="载波侦听多路访问CSMA"><a href="#载波侦听多路访问CSMA" class="headerlink" title="载波侦听多路访问CSMA"></a>载波侦听多路访问<code>CSMA</code></h4><p>两个重要的规则：</p>
<p>1）说话之前先听。如果其他人正在说话，等到他们说完话为止。在网络领域中，这被称为<strong>载波侦听</strong><code>carrier sensing</code>，即一个节点在传输前先听信道。如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输</p>
<p>2）如果与他人同时开始说话，停止说话。在网络领域中，这被称为<strong>碰撞检测</strong><code>collision detection</code>，即当一个传输节点在传输时一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时传输”循环之前等待一段随机时间</p>
<p>这两个规则包含在<strong>载波侦听多路访问</strong><code>Carrier Sense Multiple Access, CSMA</code>和<strong>具有碰撞检测的CSMA</strong><code>CSMA  with Collision Detection, CSMA/CD</code>协议族中</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/CSMA.png" class>

<p>从图中可以看出，显然广播信道的端到端<strong>信道传播时延</strong><code>channel propagation delay</code>（信号从一个节点传播到另一个节点所花费的时间）在决定其性能方面起着关键的作用。该传播时延越长，载波侦听节点不能侦听到网络中另一个节点已经开始传输的机会就越大。如果一个节点开始传播后发送碰撞，其实此次传播已经失败，将剩余数据传完没有意义，即使中止才是上策，这便是具有CSMA/CD所作改进</p>
<img src="/2021/11/22/%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/CSMA_CD.png" class>

<h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><p><strong>轮询协议</strong><code>polling protocol</code></p>
<p><strong>令牌传递协议</strong><code>token-passing protocol</code></p>
<h2 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h2><p>链路层地址有各种不同的称呼：<strong>LAN地址</strong><code>LAN address</code>、<strong>物理地址</strong><code>physical address</code>或<strong>MAC地址</strong><code>MAC address</code></p>
<p>适配器的MAC地址具有扁平结构（这与层次结构相反），而且不论适配器到哪里用都不会发送变化</p>
<p>因为存在网络层地址（例如，因特网的IP地址）和链路层地址（即MAC地址），所以需要在它们之间进行转换。对于因特网而言，这是<strong>地址解析协议</strong><code>Address Resolution Protocol, ARP</code></p>
<p>对路由器的每个接口，（在路由器中）也有一个ARP模块，一个IP地址</p>
<p><strong>注意，链路层交换机是没有MAC地址的</strong></p>
<p>交换机是<strong>自学习</strong><code>self-learning</code>的，是<strong>即插即用设备</strong><code>plug-and-play device</code></p>
<p>剩下的感觉也不怎么考，杨老师的PPT做得太好了。。。甚至感觉我的笔记都没啥太大必要，直接看PPT就好。。。。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本博客中所有图片均来自杨频老师《计算机网络》PPT</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>特别感谢网安学院杨频教授授权我使用其PPT。杨老师的PPT重点突出且格式优美，对我对计算机网络的学习帮助巨大，再次感谢杨老师！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/21/%E7%AC%94%E8%AE%B0-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/21/%E7%AC%94%E8%AE%B0-C++/" class="post-title-link" itemprop="url">C++笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-21 10:24:23" itemprop="dateCreated datePublished" datetime="2021-11-21T10:24:23+08:00">2021-11-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-13 10:44:23" itemprop="dateModified" datetime="2021-12-13T10:44:23+08:00">2021-12-13</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-面向对象高级编程"><a href="#C-面向对象高级编程" class="headerlink" title="C++面向对象高级编程"></a>C++面向对象高级编程</h1><h2 id="防卫式声明"><a href="#防卫式声明" class="headerlink" title="防卫式声明"></a>防卫式声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MYSTRING__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MYSTRING__</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>如果函数在<code>class body</code>内定义完成，便自动成为<code>inline</code>候选人</p>
<h2 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h2><p>尽量使用<code>initialization list</code>初始化</p>
<p>一个变量数值的设定有两个阶段，初始化阶段和赋值阶段。<code>initialization list</code>是第一阶段设定，在花括号内用<code>=</code>符号赋值是第二阶段</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> h, w;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rectangle(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span><br><span class="line">        :h(height), w(width) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>传引用，返回引用，如果可以的话</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp; </span><br><span class="line">__doap1(<span class="built_in">complex</span>* ths, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递者无需知道接收者是以<code>reference</code>形式接收</p>
<h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><p>总是应该考虑类的成员函数是否改变类的数据成员。若不改变，应显式地用<code>const</code>关键字限制函数行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="含有指针的类"><a href="#含有指针的类" class="headerlink" title="含有指针的类"></a>含有指针的类</h2><p>如果指针是类的成员，则应仔细考虑拷贝构造函数，赋值函数和析构函数的编写，避免浅拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>);</span><br><span class="line">    String(<span class="keyword">const</span> String&amp; str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> String&amp; str);</span><br><span class="line">    ~String();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于赋值运算符重载函数，一定要先检查是否自我赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="array-new一定要搭配array-delete"><a href="#array-new一定要搭配array-delete" class="headerlink" title="array new一定要搭配array delete"></a>array new一定要搭配array delete</h2><p>就是说，用<code>new</code>关键词动态分配了一个数组，释放内存时一定得用<code>delete []</code>释放整个数组。如果没有加上中括号，可能会导致内存泄漏。</p>
<p>为什么只是<strong>可能</strong>？例如你动态分配N个某种类型的对象，它们是连在一起放在内存的某一块地方，负责管理的数据结构会记录这一块存的东西占了多大空间，存了多少个对象等等。所以当使用<code>delete</code>释放内存时，无论加不加中括号，N个对象的空间都会被回收，内存泄漏并不是发生在这里。试想，若这N个对象每个也都动态申请了内存，那么每个对象死亡时按理应该调用析构函数释放内存。如果使用<code>delete[]</code>，编译器知道释放的是一个数组，编译器会分别调用这N个对象的析构函数，确保每个函数动态申请的空间都被释放掉，没有内存泄漏；但如果没有加上中括号，编译器以为释放的不是数组而只是一个元素，于是只会调用数组里第一个元素的析构函数，剩余元素的析构函数没有调用，它们所动态申请的空间也因此没有释放，导致了内存泄漏。</p>
<p>综上，如果动态申请一个对象数组，如果每个对象并没有动态申请空间，那么就算释放数组时忘记加中括号也不会有啥实际问题，但若每个对象单独又申请了空间，那么除了第一个元素外，剩余元素的动态申请的空间都没有回收，造成了泄漏</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>构造由内而外，析构由外而内</p>
<h1 id="C-程序设计兼谈对象模型"><a href="#C-程序设计兼谈对象模型" class="headerlink" title="C++程序设计兼谈对象模型"></a>C++程序设计兼谈对象模型</h1><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><p>转换函数能将一种类型的对象转换为另一种类型的对象，试想，你编写了一个分数类(Fraction)，该类成员变量为分子和分母，将该类的对象转换为一个浮点数用于算术运算是否是比较合乎情理的呢？于是，我们在类中添加<code>operator double()</code>转换函数，负责在需要时将该类的对象转换为<code>double</code>类型的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Fraction(duoble num, <span class="keyword">double</span> den = <span class="number">1</span>)</span><br><span class="line">	 : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> m_numerator / m_denominator; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> m_numerator;		<span class="comment">//分子</span></span><br><span class="line">	<span class="keyword">double</span> m_denominator;	<span class="comment">//分母</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编写如上转换函数后，我们可以将此类对象直接用于算数运算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.0</span>, <span class="number">5.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">4</span> + f;</span><br></pre></td></tr></table></figure>

<p>当执行<code>d = 4 + f</code>语句时，编译器首先查看是否存在一个操作符重载函数，它的第一个参数是整数（或浮点数），第二个参数是<code>Fraction</code>类型的对象，没有这么个函数。于是又找是否存在转换函数，将<code>Fraction</code>类型的对象转换为<code>double</code>类型对象，找到了，于是调用该函数，将其转换为一个浮点值参与运算</p>
<p>需注意，<code>operator double() const</code>函数没有返回值</p>
<h2 id="non-explicit-one-argument-constructor"><a href="#non-explicit-one-argument-constructor" class="headerlink" title="non-explicit one argument constructor"></a>non-explicit one argument constructor</h2><p>C++中既然存在上面提到的转换函数这种“把自己的类型对象转换为别的类型对象”的方法，也有“将其他类型对象转换为自己类型对象”的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Fraction(duoble num, <span class="keyword">double</span> den = <span class="number">1</span>)</span><br><span class="line">	 : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">	Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Fraciton(...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> m_numerator;		<span class="comment">//分子</span></span><br><span class="line">	<span class="keyword">double</span> m_denominator;	<span class="comment">//分母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先观察该类的构造函数，有两个参数，但第二个有默认值，实际使用的时候可以只指明第一个参数值即可。可以说这个构造函数有两个<code>parameter</code>，而只有第一个参数是没有指明默认值的(<code>non-explicit one argument</code>)。再考虑<code>d2 = f + 4;</code>，<code>f</code>位于加号的左边，看起来有点满足<code>Fraction</code>类的加号重载函数，但是加号重载函数要求的参数是一个<code>Fraction</code>类的对象，而此时能作为参数的只有一个<code>4</code>，那能不能考虑将<code>4</code>从<code>int</code>类型转换为<code>Fraction</code>类型呢？整数<code>4</code>可以看作分数<code>4/1</code>，这符合我们的常识，编译器用<code>Fraction</code>类的构造函数，将<code>4</code>作为第一个参数，而第二个参数取默认值<code>1</code>，将原本<code>int</code>类的对象<code>4</code>转换为一个<code>Fraction</code>对象，于是加法得以进行</p>
<p>（以上解释是侯捷老师在课程中的解释，但说实话我还是不太明白编译器为啥就知道默默地去用构造函数来进行类型转换）</p>
<p>再看下述代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Fraction(duoble num, <span class="keyword">double</span> den = <span class="number">1</span>)</span><br><span class="line">	 : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> m_numerator / m_denominator; &#125;</span><br><span class="line">    </span><br><span class="line">	Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Fraciton(...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> m_numerator;		<span class="comment">//分子</span></span><br><span class="line">	<span class="keyword">double</span> m_denominator;	<span class="comment">//分母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>; <span class="comment">//[Error]ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里main函数里的加法，将<code>f</code>转换为<code>double</code>类型对象也走得通，将数值<code>4</code>转换为<code>Fraction</code>类型对象也走得通，语句具有二义性，因此编译报错。但如果改变加法顺序</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Fraction</span> d<span class="number">2</span> = <span class="number">4</span> + f;</span><br></pre></td></tr></table></figure>

<p>分析知此情形只能是将<code>f</code>转换为<code>double</code>类型</p>
<h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><p>explicit的意思是“清楚明白的，明确的，详述的；直截了当的，坦率的”。将其用于修饰构造函数，告诉编译器，“这个构造函数只能用于它的本职工作——在创建该类对象时进行初始化，别偷偷拿去搞什么类型转换的事情”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(duoble num, <span class="keyword">double</span> den = <span class="number">1</span>)</span></span></span><br><span class="line">	 : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> m_numerator / m_denominator; &#125;</span><br><span class="line">    </span><br><span class="line">	Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Fraciton(...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> m_numerator;		<span class="comment">//分子</span></span><br><span class="line">	<span class="keyword">double</span> m_denominator;	<span class="comment">//分母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>; <span class="comment">//[Error]conversion from &#x27;double&#x27; to &#x27;Fraction&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上<code>explicit</code>关键字后，由于参数类型不匹配，加号运算符重载这条路走不通了，因此<code>f + 4</code>唯一合理的解释就是将<code>f</code>通过转换函数转换为<code>double</code>类型的对象</p>
<h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h2><p>以智能指针为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> *px; &#125;</span><br><span class="line">	</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> px; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">shared_ptr</span>(T* p): px(p) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T*		px;</span><br><span class="line">	<span class="keyword">long</span>*	pn;</span><br><span class="line">...	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>智能指针用起来得像一个指针，所以得重载以上两个运算符。值得注意的是<code>-&gt;</code>运算符的重载，试想，若用户如此使用智能指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line">sp-&gt;method();</span><br></pre></td></tr></table></figure>

<p>实际上用户是想</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">px-&gt;<span class="function"><span class="keyword">method</span>(</span>);</span><br></pre></td></tr></table></figure>

<p>但观察我们的<code>-&gt;</code>重载函数发现，重载函数已经将<code>-&gt;</code>运算符用掉了，让人产生疑惑。侯捷老师对此的解释是，<code>-&gt;</code>运算符很特别，它作用下去得到的结果会继续作用下去，因此该运算法能继续为<code>px</code>所用，上述的写法是行得通的</p>
<p>那不禁追问，为什么<code>-&gt;</code>运算符就恰好能行得通呢？答案是：语言是人创造的，语言的创造者想到了要这么用<code>-&gt;</code>运算符，就在底层实现了对如此使用的支持</p>
<h2 id="function-like-classes（仿函数）"><a href="#function-like-classes（仿函数）" class="headerlink" title="function-like classes（仿函数）"></a>function-like classes（仿函数）</h2><p>说实话这一节学得并不很懂，一个仿函数的实例如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> T&amp;</span><br><span class="line">	<span class="keyword">operator</span>() (<span class="keyword">const</span> T&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用它</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> d1 = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">double</span> d2 = identity&lt;<span class="built_in">double</span>&gt;()(d1);</span><br></pre></td></tr></table></figure>

<p>第一对括号是生成<code>identity&lt;double&gt;</code>类型的临时对象，第二对括号里是函数的参数。语句将<code>d2</code>的值设为<code>5</code></p>
<h2 id="function-template-函数模板"><a href="#function-template-函数模板" class="headerlink" title="function template 函数模板"></a>function template 函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数模板在使用时可以不指定类型（当然，指定也可以），编译器会自动进行<strong>实参推导</strong><code>argument deduction</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stone r1(2, 3), r2(1, 4), r3;</span><br><span class="line">r3 = min(r1, r2);</span><br></pre></td></tr></table></figure>

<h2 id="member-template-成员模板"><a href="#member-template-成员模板" class="headerlink" title="member template 成员模板"></a>member template 成员模板</h2><p>一个模板内部又有模板，则里面嵌套这个就是成员模板。常用于构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">	T1 first;</span><br><span class="line">	T2 second;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">pair</span>(): first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">	pari(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b)</span><br><span class="line">		: first(a), second(b) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="keyword">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line">	<span class="built_in">pair</span>(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;U1, U2&gt;&amp; p)</span><br><span class="line">		: first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>试想这么一种情形：有两个基类，每个基类分别派生出一个派生类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> <span class="keyword">public</span> Base1 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> Base1 &#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;Derived1, Derived2&gt; p;</span><br><span class="line">pair&lt;Base1, Base2&gt; p2(p);</span><br><span class="line"><span class="comment">//等价于pair&lt;Base1, Base2&gt; p2(pair&lt;Drived1, Drived2&gt;());</span></span><br></pre></td></tr></table></figure>

<p>用对象<code>p</code>作为参数构造<code>p2</code>，<code>p2</code>调用的是成员模板的构造函数，可以这么做吗？用派生类对象给基类对象赋值？可以，这称为向上造型<code>up-cast</code></p>
<h2 id="specialization-特化"><a href="#specialization-特化" class="headerlink" title="specialization 特化"></a>specialization 特化</h2><p>特化与泛化整好相反，特化指定类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用特化结构对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hash&lt;<span class="keyword">char</span>&gt;()(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>关键词<code>template</code>后面接一对空的尖括号</p>
<p>函数名后加上一对尖括号，尖括号中指定需要特化的类型</p>
<h2 id="partial-specialization-偏特化"><a href="#partial-specialization-偏特化" class="headerlink" title="partial specialization 偏特化"></a>partial specialization 偏特化</h2><p>有两种类型的偏特化</p>
<p>1）个数的偏</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是没有特化的模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是指定了一个泛化类型的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>&lt;</span><span class="keyword">bool</span>, Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是没有特化的模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是指定了一个泛化类型的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="function">class <span class="title">sample</span><span class="params">(T1, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2）范围的偏</p>
<p>先看例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类模板的范围从T类型特化到了T的指针类型，范围缩小了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;</span>T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C&lt;string&gt; obj1<span class="comment">;</span></span><br><span class="line">C&lt;string*&gt; obj2<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>使用时，若实际类型不是指针，则生成的是没有特化的类模板的对象<code>obj1</code>，若类型是指针，则生成的是范围特化了的类模板的对象<code>obj2</code>；注意，没特化的类模板和特化了的类模板看起来很像，但实际完全是两个东西，没啥关联</p>
<h2 id="template-template-parameter-模板模板参数"><a href="#template-template-parameter-模板模板参数" class="headerlink" title="template template parameter 模板模板参数"></a>template template parameter 模板模板参数</h2><p>一句话，一个模板的参数又是一个模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SmartPtr&lt;T&gt; sp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	XCls(): sp(<span class="keyword">new</span> T) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XCls&lt;<span class="built_in">string</span>, <span class="built_in">shared_ptr</span>&gt; p1;</span><br></pre></td></tr></table></figure>

<p>注意到模板的参数和模板的参数模板的参数都是T。这样，当模板的第一个参数T确定时，参数模板的参数也随之确定，很自然就有<code>SmartPtr&lt;T&gt;</code>这样的用法</p>
<p>模板模板参数有什么用？见下面这个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = <span class="built_in">list</span>&lt;T, allocator&lt;T&gt;&gt;;		<span class="comment">//前两行暂时不用管</span></span><br><span class="line">	XCls&lt;<span class="built_in">string</span>, Lst&gt; mylist;</span><br></pre></td></tr></table></figure>

<p>第一个参数决定存储数据类型，第二个参数决定用于存储的容器类型</p>
<p>看另一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> <span class="built_in">deque</span>&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== &lt;&gt; (<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; &lt;&gt; (<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c; 	<span class="comment">//底层容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br></pre></td></tr></table></figure>

<p>注意，这个例子不是模板模板参数，即其第二个参数不是模板。在使用<code>stack</code>时，第二个参数要显示指明<code>list</code>存储的对象类型，直接绑定死了，但之前例子里的模板模板参数在使用时第二个参数是不显式指定容器的参数类型的，而是在模板代码里绑定</p>
<h2 id="variadic-templates-数量不定的模板参数"><a href="#variadic-templates-数量不定的模板参数" class="headerlink" title="variadic templates 数量不定的模板参数"></a>variadic templates 数量不定的模板参数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">7.5</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">false</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>两点值得注意：1）<code>typename...</code>，<code>Types&amp;...</code>以及<code>args...</code>，三个点是语法的一部分，表示数目不定（0个或多个），如果想知道可变参数的个数可使用<code>sizeof...(args)</code>；2）注意到代码第一行有一个无参数的<code>print()</code>函数。当第四行有参数的<code>print()</code>不停递归调用自身时，每递归一次参数减少一个，当参数数目为零时不满足第四行的<code>print()</code>的调用要求（第四行这个函数要求至少有一个参数）。因此，若不写一个无参的<code>print()</code>，则编译出错</p>
<p>令我有点困惑的是在使用时不指明模板类型，而是直接传递函数参数调用函数，由函数参数类型自动倒推模板参数类型？虽然确实可以运行得到正确结果，还是不太明白背后的原理</p>
<h2 id="reference-引用"><a href="#reference-引用" class="headerlink" title="reference 引用"></a>reference 引用</h2><p>实际上，引用底层是用指针实现的，但它给人一种假象，似乎它真就是引用对象的别名</p>
<p>定义一个对象<code>int x = 0;</code>，再用一个引用对象引用它<code>int&amp; rx = x;</code>，对象和引用实际储存在内存里两个<strong>不同</strong>的位置，而且由于引用底层是指针实现的，理论上它的大小是该机器上指针大小（一半4字节或8字节），但对象的大小可大可小，没有限制。所以理论上对象和引用的大小可以不同，地址也不同。但是，当你使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(x) == <span class="keyword">sizeof</span>(rx);</span><br><span class="line">&amp;x == &amp;rx;</span><br></pre></td></tr></table></figure>

<p>进行比较判别是，会发现这两个判等表达式总是为真。故引用提供了一种假象，好似真的只是别名，让用户用起来十分便捷。引用的一个较大用处就是函数参数可以设置为传引用。的确，引用能实现的直接用指针也能实现，但用引用实现更加优雅</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Cls* pobj)</span> </span>&#123; pobj-&gt;xxx(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Cls  obj)</span>  </span>&#123; obj.xxx(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(Cls&amp; obj)</span>  </span>&#123; obj.xxx(); &#125;</span><br><span class="line">...</span><br><span class="line">	Cls obj;</span><br><span class="line">	func1(&amp;obj);	<span class="comment">//接口不同</span></span><br><span class="line">	func2(obj);</span><br><span class="line">	func3(obj);</span><br></pre></td></tr></table></figure>

<p>以上述代码为例，三个函数分别是传指针，传值和传参数。观察发现，传值和传引用接口相同，而传指针较为特别</p>
<p>需注意</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>  im)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>此两函数的函数签名<code>signature</code>被视作相同，故不能同时存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> im)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> im)</span>       </span>&#123; ... &#125;</span><br><span class="line">或</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span>       </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>对于这两组函数中的一组，在函数名，参数表均相同的情况下，一个函数用<code>const</code>修饰，另一个没有，故其函数签名<strong>不一样</strong>，可同时存在。老实说为啥有无<code>const</code>能区分两个几乎一模一样的函数让我感到很疑惑，我也想不到合适的例子说服自己，但侯捷老师说它们不同，我也只好先保留疑惑</p>
<p>2021/12/5 更新：疑惑已解决，见”谈谈const“小节</p>
<h2 id="关于vptr和vtbl"><a href="#关于vptr和vtbl" class="headerlink" title="关于vptr和vtbl"></a>关于vptr和vtbl</h2><img src="/2021/11/21/%E7%AC%94%E8%AE%B0-C++/vptr_vtbl.png" class>

<p>父类有虚函数，子类必然继承父类的虚函数。一个类有虚函数意味着什么呢？从内存的角度看，一个类有虚函数，意味着这个类存在一个<strong>虚指针</strong><code>virtual pointer</code>，所以即使一个类除了虚函数其他啥数据也没有，用<code>sizeof()</code>去测这个类的对象的大小，会得到4或8，即一个指针的大小。虚指针指向一个<strong>虚函数表</strong><code>virtual table</code>。虚函数表里是该类从父类那里继承而来的各个虚函数以及该类自己定义的新的虚函数（如果有的话）</p>
<p>注意，假设class A有两个虚函数<code>func1(), func2()</code>，class B继承自class A，而 class C又继承自class B。自然，这三个类都有自己的虚指针，<strong>但是三个类的指针指向的是三张不同的表</strong>。假如class B只重写了<code>func1()</code>，没有重写<code>func2()</code>，那么在class B的虚函数表里，一个表项指向的是原本class A的<code>func2()</code>的地址，另一个表项是指向一个新的、class B自己重写的<code>func1()</code>的地址。class B的<code>func1()</code>和class A的<code>func1()</code>是两个<strong>完全不同</strong>的函数。同理，若class C也是只重写了继承自class B的<code>func1()</code>，却没有重写<code>func2()</code>，则在class C的虚表中，一个表项指向class C自己的<code>fun1()</code>的地址，而另一个表项则是指向继承自class B的<code>func2()</code>，而class B的<code>func2()</code>其实也是从class A继承而来，因此，实际上class C的虚表的这个表项实际上最终是指向class A的<code>func2()</code>的地址。故在此例中，实际上只有四个虚函数：class A的<code>func1(), func2()</code>，class B的<code>func2()</code>和class C的<code>func2()</code>。三张不同的虚表，而每张虚表都有一个表项是指向class A的<code>func2()</code>的地址</p>
<p>我们可以用父类的指针指向子类的对象，因为子类对象<strong>是</strong>一个父类对象。例如有<code>animal</code>这个类，而它有<code>dog</code>这么个子类，<code>dog</code>当然<strong>是</strong><code>animal</code>，因此可以按如下方式使用，称为<code>up-cast</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;animal*&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="keyword">new</span> dog());</span><br></pre></td></tr></table></figure>

<p>而<code>animal</code>不一定是<code>dog</code>，因此不能用<code>dog</code>类型的指针指向<code>animal</code>类型的对象</p>
<p>如果<code>animal</code>类有一个虚函数<code>func1()</code>，<code>dog</code>类重写了这个函数。当我们用<code>animal</code>类的指针指向<code>dog</code>类的对象，并通过这个指针调用<code>func1()</code>函数时，我们其实希望调用的是<code>dog</code>类的<code>func1()</code>函数，因此，编译器不能看到指针类型是<code>animal</code>就直接调用<code>animal</code>类型的<code>func1()</code>，而应分析指针指向的对象实际是什么类型，调用实际指向的对象类型的<code>func1()</code>。这称为<strong>动态绑定</strong><code>dynamic binding</code>，传统C语言那种函数调用称为<strong>静态绑定</strong><code>static binding</code></p>
<h2 id="关于Dynamic-Binding"><a href="#关于Dynamic-Binding" class="headerlink" title="关于Dynamic Binding"></a>关于Dynamic Binding</h2><p>注意，只有涉及指针时才考虑是否动态绑定，例如假设class A有虚函数<code>func()</code>，class B继承自class A，并且class B重写了<code>func()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">A a = (A)b;</span><br><span class="line">a.func();</span><br></pre></td></tr></table></figure>

<p>这不是用A类型的指针去指B类型对象，而是把B类型对象强制转换为A类型对象。因此，如果通过a去调用虚函数，调用的是<code>A::func()</code>，但如果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">A* a = <span class="keyword">new</span> B();</span><br><span class="line">a-&gt;func();</span><br></pre></td></tr></table></figure>

<p>这种情况下，则调用的是<code>B::func()</code></p>
<h2 id="谈谈const"><a href="#谈谈const" class="headerlink" title="谈谈const"></a>谈谈const</h2><p>这一小节解决了之前遗留的一个疑惑：两个同名同参数的函数，一个用const修饰，一个没有，它们的函数签名是<strong>不一样的</strong>，即它俩可以并存，之前我就一直搞不懂那我调用时调用的是其中哪一个</p>
<p>注意，首先这里讨论的是类的成员函数，其次，上文所说的用const修饰是指</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而不是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">char</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2021/11/21/%E7%AC%94%E8%AE%B0-C++/const.png" class>

<p>一个成员函数用const修饰代表它一定不会修改该类的成员变量，而不加const则说明它可能改变成员变量。因此用const修饰的成员变量只可能被同为const修饰的成员函数调用，而不可能被没const修饰的成员函数调用。但如果成员变量本身不是const修饰的，那无论成员函数是否有const修饰都可以调用它。这就存在我之前所产生的疑惑：当两个同名同参数函数同时存在，其中一个是const,另一个是非const,那么在调用时如何知道调用的究竟是哪个呢？</p>
<p>答案见图中上方小字：当两个版本的成员函数同时存在时，const object调用const版本的函数，non-const object调用non-const版本，这就解决了我的疑惑</p>
<p>这个知识点的用处何在呢？阅读上图右方的代码，basic_string是string底层的实现。我们可以有多个string对象，它们实际指向同一地址的字符串，以到达节约空间之效，而当某对象欲修改字符串内容时，为避免其行为影响到其他对象，因此必须进行<strong>写时复制</strong>。也就是说，平时通过<code>[]</code>运算符取字符串内容时，我们调用图右侧上方const版本的函数，而当通过该运算符修改字符串内容时，调用图右侧下方的non-const版本的函数，可在该函数中对字符串进行写时复制，避免错误发生</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/27/GameTheory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/27/GameTheory/" class="post-title-link" itemprop="url">GameTheory</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-27 23:37:34 / 修改时间：23:48:58" itemprop="dateCreated datePublished" datetime="2021-10-27T23:37:34+08:00">2021-10-27</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>几个博弈论相关的游戏，挺有趣的，随手记录了</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/10/27/GameTheory/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/27/%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/27/%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">零碎的知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-27 23:32:37" itemprop="dateCreated datePublished" datetime="2021-10-27T23:32:37+08:00">2021-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-29 18:42:49" itemprop="dateModified" datetime="2021-10-29T18:42:49+08:00">2021-10-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>记录学习过程中遇到的各种知识点</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/10/27/%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/27/APUE%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/27/APUE%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">APUE-习题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-27 23:16:08" itemprop="dateCreated datePublished" datetime="2021-10-27T23:16:08+08:00">2021-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-29 21:06:48" itemprop="dateModified" datetime="2021-10-29T21:06:48+08:00">2021-10-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>817</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>APUE中文第三版习题解答</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/10/27/APUE%E4%B9%A0%E9%A2%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/27/APUE%E9%9A%8F%E7%AC%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/27/APUE%E9%9A%8F%E7%AC%94/" class="post-title-link" itemprop="url">APUE笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-27 23:15:29" itemprop="dateCreated datePublished" datetime="2021-10-27T23:15:29+08:00">2021-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-29 21:29:08" itemprop="dateModified" datetime="2021-10-29T21:29:08+08:00">2021-10-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>398</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>记录学习APUE过程中的点点滴滴</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/10/27/APUE%E9%9A%8F%E7%AC%94/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/17/fezOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FEZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/17/fezOS/" class="post-title-link" itemprop="url">fezOS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-17 21:57:57" itemprop="dateCreated datePublished" datetime="2021-09-17T21:57:57+08:00">2021-09-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-14 18:22:02" itemprop="dateModified" datetime="2021-12-14T18:22:02+08:00">2021-12-14</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>fezOS搭建</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/09/17/fezOS/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FEZ</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">443k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:43</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
